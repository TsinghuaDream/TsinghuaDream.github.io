{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"深入浅出springboot2有感","date":"2021-04-01T09:23:17.000Z","updated":"2021-04-02T08:20:19.696Z","comments":true,"path":"api/articles/深入浅出springboot2有感.json","keywords":null,"cover":null,"content":"<h1 id=\"全注解下的spring-ioc\"><a href=\"#全注解下的spring-ioc\" class=\"headerlink\" title=\"全注解下的spring ioc\"></a>全注解下的spring ioc</h1><p>spring最成功的便是其提出的两个理念 （ IOC和AOP) 控制反转和面向切面编程。</p>\n<p>其中ioc容器思想是spring的核心，而spring是基于注解开发的spring ioc 所以重点分析全注解下的spring ioc。</p>\n<p>IoC是一种通过描述来生成或者获取对象的技术，而这个技术不是Spring甚至不是Java独有的。对于Java初学者更多的时候所熟悉的是使用new关键字来创建对象，而在Spring中则不是，它是<strong>通过描述来创建对象</strong>。只是Spring Boot并不建议使用XML，而是通过注解的描述生成对象。</p>\n<p>一个系统可以生成各种对象，并且这些对象都需要进行管理。值得一提的事，对象之间并不孤立，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成，那么班级就依赖于多个老师和同学。为了解藕，spring还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。</p>\n<p>而为了描述上述班级、同学和老师这三个对象关系，我们需要一个容器。在spring中把每一个需要管理的对象称为spring bean，而spring管理这些bean的容器，被我们称为spring ioc容器（或者简称ioc容器）。ioc容器需要具备两个基本功能：</p>\n<ul>\n<li><p>通过描述管理bean，包括发布和获取bean；</p>\n</li>\n<li><p>通过描述完成bean之间的依赖关系。</p>\n</li>\n</ul>\n<h2 id=\"ioc容器分析\"><a href=\"#ioc容器分析\" class=\"headerlink\" title=\"ioc容器分析\"></a>ioc容器分析</h2><p>ioc是一个管理bean的容器，在spring的定义中，它要求<strong>所有的ioc容器都需要实现接口beanfactory</strong>，它是一个顶级容器接口。</p>\n<p>beanfactory接口源码分析：</p>\n<h2 id=\"装配Bean\"><a href=\"#装配Bean\" class=\"headerlink\" title=\"装配Bean\"></a>装配Bean</h2><p>在spring中允许我们通过xml或者Java配置文件装配bean，但是由于spring boot是基于注解的方式，因此下面主要基于注解的方式来介绍spring的用法，以满足spring boot开发者的需要。</p>\n<h3 id=\"自动扫描装配Bean\"><a href=\"#自动扫描装配Bean\" class=\"headerlink\" title=\"自动扫描装配Bean\"></a>自动扫描装配Bean</h3><p>如果一个个的bean使用注解@Bean注入spring ioc容器中，那将是一件很麻烦的事情。好在spring还允许我们进行扫描装配bean到ioc容器中，对于<strong>扫描装配而言使用的注解是@Component和@componentSca</strong>。<br><strong>@Component是标明哪个类被扫描进入spring ioc容器，而@ComponentScan则是标明采用何种策略去扫描装配Bean</strong>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Componente</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\t<span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"user_name_1\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> userName<span class=\"token punctuation\">;</span>\n\t<span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"note_1\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> note<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/** some code about getter and setter**/</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的注解**@Component表明这个类将被Spring IoC容器扫描装配<strong>，其中配置的“user”则是作为Bean的名称，当然你也可以不配置这个字符串，那么IoC容器就会把类名第一个字母作为小写，其他不变作为Bean名称放入到IoC容器中；</strong>注解@Value则是指定具体的值，使得Spring IoC给予对应的属性注入对应的值**。为了让Spring IoC容器装配这个类，需要改造类AppConfig，如代码清单3-6所示。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token annotation punctuation\">@ComponentScan</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppConfig</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这里加入@ComponentScan,意味着它会进行扫描，但是它只会扫描类AppConfig所在的当前包和其子包，之前把User.java移到包com.springboot.chapter3.config就是这个原因。这样就可以删掉之前使用@Bean标注的创建对象方法。然后进行测试，测试代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ApplicationContext</span> ctx <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AnnotationConfigApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AppConfig</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlog<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n","feature":null,"text":"全注解下的spring iocspring最成功的便是其提出的两个理念 （ IOC和AOP) 控制反转和面向切面编程。 其中ioc容器思想是spring的核心，而spring是基于注解开发的spring ioc 所以重点分析全注解下的spring ioc。 IoC是一种通过描述来...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"spring boot","slug":"spring-boot","count":1,"path":"api/tags/spring-boot.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84spring-ioc\"><span class=\"toc-text\">全注解下的spring ioc</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ioc%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90\"><span class=\"toc-text\">ioc容器分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%85%8DBean\"><span class=\"toc-text\">装配Bean</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E8%A3%85%E9%85%8DBean\"><span class=\"toc-text\">自动扫描装配Bean</span></a></li></ol></li></ol></li></ol>","author":{"name":"Phoenix","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我在天台抽着烟 我抽一半，风抽一半 我没和风计较 因为风也有自己的忧愁","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Linux性能调优","uid":"94cb37335dcf3a428e4a1d020fa13c9d","slug":"Linux性能调优","date":"2021-04-02T08:20:57.000Z","updated":"2021-04-02T08:46:07.203Z","comments":true,"path":"api/articles/Linux性能调优.json","keywords":null,"cover":[],"text":"一、前提我们可以在文章的开始就列出一个列表，列出可能影响Linux操作系统性能的一些调优参数，但这样做其实并没有什么价值。因为性能调优是一个非常困难的任务，它要求对硬件、操作系统、和应用都有着相当深入的了解。如果性能调优非常简单的话，那些我们要列出的调优参数早就写入硬件的微码或者...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"Phoenix","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我在天台抽着烟 我抽一半，风抽一半 我没和风计较 因为风也有自己的忧愁","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"servlet","uid":"9da32cf7dee442ab70933258c7f0a51d","slug":"servlet","date":"2021-04-01T08:03:01.000Z","updated":"2021-04-01T08:17:34.942Z","comments":true,"path":"api/articles/servlet.json","keywords":null,"cover":null,"text":"古老的技术Servlettomcattomcat是一个web服务器（同时也是servlet容器），通过它我们可以很方便地接收和返回到请求（如果不用tomcat，那我们需要自己写socket来接收和返回请求）。 各个目录的含义： bin：存放启动和关闭tomcat的脚本文件 con...","link":"","photos":[],"count_time":{"symbolsCount":673,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"}],"author":{"name":"Phoenix","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"我在天台抽着烟 我抽一半，风抽一半 我没和风计较 因为风也有自己的忧愁","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}