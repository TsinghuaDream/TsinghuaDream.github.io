[{"id":"9d70bbecc91e27513f6ed7bf7639b91e","title":"Filte（过滤器）、Listener（监听器）","content":"","slug":"Filte（过滤器）、Listener（监听器）","date":"2021-04-26T02:41:27.000Z","categories_index":"","tags_index":"java-web","author_index":"Phoenix"},{"id":"361efd3640c3afad4991a36fafc84e91","title":"Java8语法糖","content":"Defualt关键字此关键字在8之前常伴随swich出现，但8把它应用到了接口上，可用它在接口中实现简单的方法。\ninterface Testy&#123;\n    public void hello();//抽象方法\n    default void hi()&#123;\n        System.out.println(\"hello\");\n    &#125;\n&#125;\nclass TestImp implements Testy&#123;\n    @Override\n    public void hello() &#123;\n        System.out.println(\"world\");\n    &#125;\n&#125;\n public class Tes&#123;\n     public static void main(String[] args) &#123;\n         TestImp testImp = new TestImp();\n         testImp.hi();\n     &#125;\n &#125;\n\n","slug":"Java8语法糖","date":"2021-04-25T21:41:49.000Z","categories_index":"","tags_index":"Java8","author_index":"Phoenix"},{"id":"990c64a3d1e54730cc99f3700f509346","title":"博客项目","content":"","slug":"博客项目","date":"2021-04-21T09:16:26.000Z","categories_index":"","tags_index":"springboot","author_index":"Phoenix"},{"id":"b5228ecd688318d2d19c78d7325d6fc2","title":"让vue入个门吧","content":"![截屏2021-04-21 下午3.20.19](让vue入个门吧/截屏2021-04-21 下午3.20.19.png)\n伟大的DOM🌲","slug":"让vue入个门吧","date":"2021-04-21T07:15:20.000Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"78bf35c97e41da6a2bdad05b63951aa3","title":"函数式编程","content":"函数式接口概述有且只有一个抽象方法 即无内容方法\n用@Functionallnterface判断是不是函数式接口\n// Java8之前：旧的写法\nRunnable runnable = new Runnable() &#123;\n  @Override\n  public void run() &#123;\n    System.out.println(\"old run\");\n  &#125;\n&#125;;\nThread t = new Thread(runnable);\n\n// Java8之后：新的写法\nRunnable runnable1 = ()->&#123;\n  System.out.println(\"lambda run\");\n&#125;;\nThread t1 = new Thread(runnable1);\n\n\nlamda可以直接将代码块传递给对象或方法\npublic static String processFile() throws IOException &#123;\n    // Java7新增的语法，try()&#123;&#125;，可自动关闭资源，减少了代码的臃肿\n    try( BufferedReader bufferedReader = \n        new BufferedReader(new  FileReader(\"D:\\\\JavaProject\\\\JavaBasicDemo\\\\test.txt\")))&#123;\n        return bufferedReader.readLine();//核心代码行 读取第一行并返回\n    &#125;\n&#125;\n//编写函数式接口\n@FunctionalInterface\ninterface FileReadInterface&#123;\n  \t// 这里接受一个BufferedReader对象，返回一个String对象\n    String process(BufferedReader reader) throws IOException;\n&#125;\n// 读取一行\nFileReadInterface fileReadInterface = reader -> reader.readLine();\n// 读取两行\nFileReadInterface fileReadInterface2 = reader -> reader.readLine() + reader.readLine();\n// 参数为第二步我们自己手写的函数式接口\npublic static String processFile(FileReadInterface fileReadInterface) throws IOException &#123;\n        try( BufferedReader bufferedReader =\n                 new BufferedReader(new FileReader(\"./test.txt\")))&#123;\n\t\t\t\t\t// 这里我们不再自己定义行为，而是交给函数式接口的抽象方法来处理，然后通过lambda表达式的传入来实现多个行为\n          return fileReadInterface.process(bufferedReader);\n        &#125;\n    &#125;\npublic class FileReaderDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n\t\t\t\t// 第三步： \n      \t// lambda表达式1 传给 函数式接口：只读取一行\n      \tFileReadInterface fileReadInterface = reader -> reader.readLine();\n\t\t\t\t// lambda表达式2 传给 函数式接口：只读取两行\n      \tFileReadInterface fileReadInterface2 = reader -> reader.readLine() + reader.readLine();\n      \t// 最后一步： 不同的函数式接口的实现，表现出不同的行为\n        String str1 = processFile(fileReadInterface);\n        String str2 = processFile(fileReadInterface2);\n        System.out.println(str1);\n        System.out.println(str2);\n    &#125;\n  \n  \t// 第四步： 读取文件方法，接受函数式接口作为参数\n    public static String processFile(FileReadInterface fileReadInterface) throws IOException &#123;\n        try( BufferedReader bufferedReader =\n                 new BufferedReader(new FileReader(\"./test.txt\")))&#123;\n\t\t\t\t\t// 调用函数式接口中的抽象方法来处理数据\t\t\t\t\t\n          return fileReadInterface.process(bufferedReader);\n        &#125;\n    &#125;\n\t// 第一步：\n  public static String processFile() throws IOException &#123;\n        try( BufferedReader bufferedReader =\n                 new BufferedReader(new FileReader(\"./test.txt\")))&#123;\n          return bufferReader.readLine();\n        &#125;\n    &#125;\n\n\n&#125;\n\n// 第二步： 我们手写的函数式接口\n@FunctionalInterface\ninterface FileReadInterface&#123;\n    String process(BufferedReader reader) throws IOException;\n&#125;\n\n@FunctionalInterface\npublic interface Function&lt;T, R> &#123;\n\t// 都是接受一个参数，返回另一个参数\n  R apply(T t);\n&#125;\n\n","slug":"函数式编程","date":"2021-04-19T02:19:13.000Z","categories_index":"Java8","tags_index":"java","author_index":"Phoenix"},{"id":"d161500ac7b3c518546366fc4b6ac5c1","title":"about","content":"","slug":"about","date":"2021-04-18T21:05:51.000Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"e5b718a5d1f1e5a5f6a02198b64823f9","title":"零星的问题们","content":"堆内存什么时候被释放？怎么调用父类的私有方法呢？（super）怎么调用自己的方法呢？（this）局部变量指是在局部改一下，存于栈内存，不会对全局变量产生影响！递归求阶乘需求：用递归求5的阶乘，并把结果在控制台输出\n分析：\n①阶乘：一个正整数的阶乘是所有小于及等于该数的正整数的积，自然数n的阶乘写作n!\n​    5! = 54321\n②递归出口：1! = 1\n③递归规则：n!=n*(n-1)!\n​    5! = 5*4!\n思路：\n①定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n②在方法内部判断该变量的值是否是1\n是：返回1\n不是：返回n*(n-1)!\n③调用方法\n输出结果\npublic class DiGuiDemo01 &#123;\n  public static void main(String[] args) &#123;\n    int result = jc(5);\n    System.out.println(\"5的阶乘是：\"+ result);\n  &#125;\n  public static int jc(int n) &#123;\n    if (n == 1) &#123;\n      return 1;\n    &#125; else &#123;\n      return n * jc(n - 1);\n    &#125;\n  &#125;\n&#125;\n\n","slug":"零星的问题们","date":"2021-04-08T02:07:57.000Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"9d47beca42e77e491b6a6382a2bca99c","title":"mysql调优","content":"MySQL数据库优化的八种方式(经典必看)引言：1. 关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂\n2. 偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助\n\n1、选取最适用的字段属性\nMySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。\n例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。\n另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。\n2、使用连接（JOIN）来代替子查询(Sub-Queries)\nMySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：\nDELETEFROMcustomerinfo\nWHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)\n\n使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：\nSELECT*FROMcustomerinfo\nWHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)\n\n如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：\nSELECT*FROMcustomerinfo\nLEFTJOINsalesinfoONcustomerinfo.CustomerID&#x3D;salesinfo.CustomerID\nWHEREsalesinfo.CustomerIDISNULL\n\n连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。\n3、使用联合(UNION)来代替手动创建的临时表\nMySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。\nSELECTName,PhoneFROMclientUNION\nSELECTName,BirthDateFROMauthorUNION\nSELECTName,SupplierFROMproduct\n\n4、事务\n尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。\nBEGIN; INSERTINTOsalesinfoSETCustomerID&#x3D;14;UPDATEinventorySETQuantity&#x3D;11WHEREitem&#x3D;&#39;book&#39;;COMMIT;\n\n事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。\n5、锁定表\n尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。\n其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。\nLOCKTABLEinventoryWRITESELECTQuantityFROMinventoryWHEREItem&#x3D;&#39;book&#39;;\n...\nUPDATEinventorySETQuantity&#x3D;11WHEREItem&#x3D;&#39;book&#39;;UNLOCKTABLES\n\n这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。\n6、使用外键\n锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。\n例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。\n \n\n\nCREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB;\n\nCREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL,\n\nPRIMARYKEY(CustomerID,SalesID),\n\nFOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB;\n\n注意例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。\n7、使用索引\n索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。\n那该对哪些字段建立索引呢？\n一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况\n例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。\n8、优化的查询语句\n绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。\n下面是应该注意的几个方面。\n\n首先，最好是在相同类型的字段间进行比较的操作。\n\n在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。\n\n\n其次，在建有索引的字段上尽量不要使用函数进行操作。\n\n\n\n例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。\n\n\n第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。\n\n例如下面的查询将会比较表中的每一条记录。\n \n\n\n\nSELECT*FROMbooks\n\nWHEREnamelike&quot;MySQL%&quot;\n\n但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：\n \n\n\n\nSELECT*FROMbooks\n\nWHEREname＞=&quot;MySQL&quot;andname＜&quot;MySQM&quot;\n\n最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。\n优化Mysql数据库的8个方法本文通过8个方法优化Mysql数据库：创建索引、复合索引、索引不会包含有NULL值的列、使用短索引、排序的索引问题、like语句操作、不要在列上进行运算、不使用NOT IN和&lt;&gt;操作\n1、创建索引对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。2、复合索引比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。3、索引不会包含有NULL值的列只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。4、使用短索引对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。5、排序的索引问题mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。6、like语句操作一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。7、不要在列上进行运算select * from users where YEAR(adddate)&lt;2007;将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select * from users where adddate&lt;‘2007-01-01’;8、不使用NOT IN和&lt;&gt;操作NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。\n数据库SQL优化大总结之 百万级数据库优化方案网上关于SQL优化的教程很多，但是比较杂乱。近日有空整理了一下，写出来跟大家分享一下，其中有错误和不足的地方，还请大家纠正补充。\n这篇文章我花费了大量的时间查找资料、修改、排版，希望大家阅读之后，感觉好的话推荐给更多的人，让更多的人看到、纠正以及补充。\n1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\nselect id from t where num is null\n\n最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.\n备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。\n不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。\n可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\nselect id from t where num &#x3D; 0\n\n\n3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。\n4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：\nselect id from t where num&#x3D;10 or Name &#x3D; &#39;admin&#39;\n\n可以这样查询：\nselect id from t where num &#x3D; 10\nunion all\nselect id from t where Name &#x3D; &#39;admin&#39;\n\n\n5.in 和 not in 也要慎用，否则会导致全表扫描，如：\nselect id from t where num in(1,2,3)\n\n对于连续的数值，能用 between 就不要用 in 了：\nselect id from t where num between 1 and 3\n\n很多时候用 exists 代替 in 是一个好的选择：\nselect num from a where num in(select num from b)\n\n用下面的语句替换：\nselect num from a where exists(select 1 from b where num&#x3D;a.num)\n\n6.下面的查询也将导致全表扫描：\nselect id from t where name like ‘%abc%’\n\n若要提高效率，可以考虑全文检索。\n7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\nselect id from t where num &#x3D; @num\n\n可以改为强制查询使用索引：\nselect id from t with(index(索引名)) where num &#x3D; @num\n\n.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\nselect id from t where num&#x2F;2 &#x3D; 100\n\n应改为:\nselect id from t where num &#x3D; 100*2\n\n\n9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\nselect id from t where substring(name,1,3) &#x3D; ’abc’       -–name以abc开头的id\nselect id from t where datediff(day,createdate,’2005-11-30′) &#x3D; 0    -–‘2005-11-30’    --生成的id\n\n应改为:\nselect id from t where name like &#39;abc%&#39;\nselect id from t where createdate &gt;&#x3D; &#39;2005-11-30&#39; and createdate &lt; &#39;2005-12-1&#39;\n\n\n10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\n12.不要写一些没有意义的查询，如需要生成一个空表结构：\nselect col1,col2 into #t from t where 1&#x3D;0\n\n这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：create table #t(…)\n13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。\n14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。\n15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。\n16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。\n17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。\n18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\n19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n20.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。\n21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。\n\\22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。\n23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。\n24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。\n25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。\n26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。\n27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。\n28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。\n29.尽量避免大事务操作，提高系统并发能力。\n30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句　　如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。　　Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。　　如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。　　所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：\nwhile(1)&#123;\n\n 　　&#x2F;&#x2F;每次只做1000条\n\n　　 mysql_query(“delete from logs where log_date &lt;&#x3D; ’2012-11-01’ limit 1000”);\n\n 　　if(mysql_affected_rows() &#x3D;&#x3D; 0)&#123;\n\n　　 　　&#x2F;&#x2F;删除完成，退出！\n　　 　　break；\n　　&#125;\n\n&#x2F;&#x2F;每次暂停一段时间，释放表让其他进程&#x2F;线程访问。\nusleep(50000)\n\n&#125;\n\n好了，到这里就写完了。我知道还有很多没有写到的，还请大家补充。后面有空会介绍一些SQL优化工具给大家。让我们一起学习，一起进步吧！\n运维角度浅谈MySQL数据库优化 一个成熟的数据库架构并不是一开始设计就具备高可用、高伸缩等特性的，它是随着用户量的增加，基础架构才逐渐完善。这篇博文主要谈MySQL数据库发展周期中所面临的问题及优化方案，暂且抛开前端应用不说，大致分为以下五个阶段：\n1、数据库表设计\n 项目立项后，开发部根据产品部需求开发项目，开发工程师工作其中一部分就是对表结构设计。对于数据库来说，这点很重要，如果设计不当，会直接影响访问速度和用户体验。影响的因素很多，比如慢查询、低效的查询语句、没有适当建立索引、数据库堵塞（死锁）等。当然，有测试工程师的团队，会做压力测试，找bug。对于没有测试工程师的团队来说，大多数开发工程师初期不会太多考虑数据库设计是否合理，而是尽快完成功能实现和交付，等项目有一定访问量后，隐藏的问题就会暴露，这时再去修改就不是这么容易的事了。\n2、数据库部署\n 该运维工程师出场了，项目初期访问量不会很大，所以单台部署足以应对在1500左右的QPS（每秒查询率）。考虑到高可用性，可采用MySQL主从复制+Keepalived做双击热备，常见集群软件有Keepalived、Heartbeat。\n双机热备博文：http://lizhenliang.blog.51cto.com/7876557/1362313\n3、数据库性能优化\n 如果将MySQL部署到普通的X86服务器上，在不经过任何优化情况下，MySQL理论值正常可以处理2000左右QPS，经过优化后，有可能会提升到2500左右QPS，否则，访问量当达到1500左右并发连接时，数据库处理性能就会变慢，而且硬件资源还很富裕，这时就该考虑软件问题了。那么怎样让数据库最大化发挥性能呢？一方面可以单台运行多个MySQL实例让服务器性能发挥到最大化，另一方面是对数据库进行优化，往往操作系统和数据库默认配置都比较保守，会对数据库发挥有一定限制，可对这些配置进行适当的调整，尽可能的处理更多连接数。\n具体优化有以下三个层面：\n 3.1 数据库配置优化\n MySQL常用有两种存储引擎，一个是MyISAM，不支持事务处理，读性能处理快，表级别锁。另一个是InnoDB，支持事务处理（ACID），设计目标是为处理大容量数据发挥最大化性能，行级别锁。\n 表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。\n 行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。\n 为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。\n 根据以上看来，使用InnoDB存储引擎是最好的选择，也是MySQL5.5以后版本中默认存储引擎。每个存储引擎相关联参数比较多，以下列出主要影响数据库性能的参数。\n 公共参数默认值：\n\n\n\n123456\nmax_connections = 151``#同时处理最大连接数，推荐设置最大连接数是上限连接数的80%左右  ``sort_buffer_size = 2M``#查询排序时缓冲区大小，只对order by和group by起作用，可增大此值为16M``open_files_limit = 1024 ``#打开文件数限制，如果show global status like &#39;open_files&#39;查看的值等于或者大于open_files_limit值时，程序会无法连接数据库或卡死\n\n\n\n\n\n\n\n MyISAM参数默认值：\n\n\n\n12345678910\nkey_buffer_size = 16M``#索引缓存区大小，一般设置物理内存的30-40%``read_buffer_size = 128K ``#读操作缓冲区大小，推荐设置16M或32M``query_cache_type = ON``#打开查询缓存功能``query_cache_limit = 1M ``#查询缓存限制，只有1M以下查询结果才会被缓存，以免结果数据较大把缓存池覆盖``query_cache_size = 16M ``#查看缓冲区大小，用于缓存SELECT查询结果，下一次有同样SELECT查询将直接从缓存池返回结果，可适当成倍增加此值\n\n\n\n\n\n\n\n InnoDB参数默认值：\n\n\n\n12345678910\ninnodb_buffer_pool_size = 128M``#索引和数据缓冲区大小，一般设置物理内存的60%-70%``innodb_buffer_pool_instances = 1  ``#缓冲池实例个数，推荐设置4个或8个``innodb_flush_log_at_trx_commit = 1 ``#关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。``innodb_file_per_table = OFF ``#默认是共享表空间，共享表空间idbdata文件不断增大，影响一定的I/O性能。推荐开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。``innodb_log_buffer_size = 8M ``#日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M\n\n\n\n\n\n\n\n 3.2 系统内核优化\n 大多数MySQL都部署在linux系统上，所以操作系统的一些参数也会影响到MySQL性能，以下对linux内核进行适当优化。\n\n\n\n12345678910\nnet.ipv4.tcp_fin_timeout = 30``#TIME_WAIT超时时间，默认是60s``net.ipv4.tcp_tw_reuse = 1  ``#1表示开启复用，允许TIME_WAIT socket重新用于新的TCP连接，0表示关闭``net.ipv4.tcp_tw_recycle = 1 ``#1表示开启TIME_WAIT socket快速回收，0表示关闭``net.ipv4.tcp_max_tw_buckets = 4096  ``#系统保持TIME_WAIT socket最大数量，如果超出这个数，系统将随机清除一些TIME_WAIT并打印警告信息``net.ipv4.tcp_max_syn_backlog = 4096``#进入SYN队列最大长度，加大队列长度可容纳更多的等待连接\n\n\n\n\n\n\n\n 在linux系统中，如果进程打开的文件句柄数量超过系统默认值1024，就会提示“too many files open”信息，所以要调整打开文件句柄限制。\n\n\n\n1234\n# vi /etc/security/limits.conf #加入以下配置，*代表所有用户，也可以指定用户，重启系统生效``* soft nofile 65535``* hard nofile 65535``# ulimit -SHn 65535  #立刻生效\n\n\n\n\n\n\n\n 3.3 硬件配置\n 加大物理内存，提高文件系统性能。linux内核会从内存中分配出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。也就是说物理内存越大，分配缓存区越大，缓存数据越多。当然，服务器故障会丢失一定的缓存数据。\n SSD硬盘代替SAS硬盘，将RAID级别调整为RAID1+0，相对于RAID1和RAID5有更好的读写性能（IOPS），毕竟数据库的压力主要来自磁盘I/O方面。\n4、数据库架构扩展\n 随着业务量越来越大，单台数据库服务器性能已无法满足业务需求，该考虑加机器了，该做集群了~~~。主要思想是分解单台数据库负载，突破磁盘I/O性能，热数据存放缓存中，降低磁盘I/O访问频率。\n 4.1 主从复制与读写分离\n 因为生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，主流的负载均衡器有LVS、HAProxy、Nginx。\n 怎么来实现读写分离呢？大多数企业是在代码层面实现读写分离，效率比较高。另一个种方式通过代理程序实现读写分离，企业中应用较少，常见代理程序有MySQL Proxy、Amoeba。在这样数据库集群架构中，大大增加数据库高并发能力，解决单台性能瓶颈问题。如果从数据库一台从库能处理2000 QPS，那么5台就能处理1w QPS，数据库横向扩展性也很容易。\n 有时，面对大量写操作的应用时，单台写性能达不到业务需求。如果做双主，就会遇到数据库数据不一致现象，产生这个原因是在应用程序不同的用户会有可能操作两台数据库，同时的更新操作造成两台数据库数据库数据发生冲突或者不一致。在单库时MySQL利用存储引擎机制表锁和行锁来保证数据完整性，怎样在多台主库时解决这个问题呢？有一套基于perl语言开发的主从复制管理工具，叫MySQL-MMM（Master-Master replication managerfor Mysql，Mysql主主复制管理器），这个工具最大的优点是在同一时间只提供一台数据库写操作，有效保证数据一致性。\n 主从复制博文：http://lizhenliang.blog.51cto.com/7876557/1290431\n 读写分离博文：http://lizhenliang.blog.51cto.com/7876557/1305083\n MySQL-MMM博文：http://lizhenliang.blog.51cto.com/7876557/1354576\n 4.2 增加缓存\n 给数据库增加缓存系统，把热数据缓存到内存中，如果缓存中有要请求的数据就不再去数据库中返回结果，提高读性能。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中。分布式缓存可以缓存海量数据，扩展性好，主流的分布式缓存系统有memcached、redis，memcached性能稳定，数据缓存在内存中，速度很快，QPS可达8w左右。如果想数据持久化就选择用redis，性能不低于memcached。\n 工作过程：\n \n 4.3 分库\n 分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。\n 4.4 分表\n 数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，怎么能解决单表压力呢？你就该考虑是否把这个表拆分成多个小表，来减轻单个表的压力，提高处理效率，此方式称为分表。\n 分表技术比较麻烦，要修改程序代码里的SQL语句，还要手动去创建其他表，也可以用merge存储引擎实现分表，相对简单许多。分表后，程序是对一个总表进行操作，这个总表不存放数据，只有一些分表的关系，以及更新数据的方式，总表会根据不同的查询，将压力分到不同的小表上，因此提高并发能力和磁盘I/O性能。\n 分表分为垂直拆分和水平拆分：\n 垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。\n 水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。\n 4.5 分区\n 分区就是把一张表的数据根据表结构中的字段（如range、list、hash等）分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。\n注：增加缓存、分库、分表和分区主要由程序猿来实现。\n5、数据库维护\n 数据库维护是运维工程师或者DBA主要工作，包括性能监控、性能分析、性能调优、数据库备份和恢复等。\n 5.1 性能状态关键指标\n QPS，Queries Per Second：每秒查询数，一台数据库每秒能够处理的查询次数\n TPS，Transactions Per Second：每秒处理事务数\n 通过show status查看运行状态，会有300多条状态信息记录，其中有几个值帮可以我们计算出QPS和TPS，如下：\n Uptime：服务器已经运行的实际，单位秒\n Questions：已经发送给数据库查询数\n Com_select：查询次数，实际操作数据库的\n Com_insert：插入次数\n Com_delete：删除次数\n Com_update：更新次数\n Com_commit：事务次数\n Com_rollback：回滚次数\n 那么，计算方法来了，基于Questions计算出QPS：\n\n\n\n12\n ``mysql&gt; show global status like ``&#39;Questions&#39;``;`` ``mysql&gt; show global status like ``&#39;Uptime&#39;``;\n\n\n\n\n\n\n\n QPS = Questions / Uptime\n 基于Com_commit和Com_rollback计算出TPS：\n\n\n\n123\n ``mysql&gt; show global status like ``&#39;Com_commit&#39;``;`` ``mysql&gt; show global status like ``&#39;Com_rollback&#39;``;`` ``mysql&gt; show global status like ``&#39;Uptime&#39;``;\n\n\n\n\n\n\n\n TPS = (Com_commit + Com_rollback) / Uptime\n 另一计算方式：基于Com_select、Com_insert、Com_delete、Com_update计算出QPS\n\n\n\n1\n ``mysql&gt; show global status where Variable_name ``in``(``&#39;com_select&#39;``,``&#39;com_insert&#39;``,``&#39;com_delete&#39;``,``&#39;com_update&#39;``);\n\n\n\n\n\n\n\n 等待1秒再执行，获取间隔差值，第二次每个变量值减去第一次对应的变量值，就是QPS\n TPS计算方法：\n\n\n\n1\n ``mysql&gt; show global status where Variable_name ``in``(``&#39;com_insert&#39;``,``&#39;com_delete&#39;``,``&#39;com_update&#39;``);\n\n\n\n\n\n\n\n 计算TPS，就不算查询操作了，计算出插入、删除、更新四个值即可。\n 经网友对这两个计算方式的测试得出，当数据库中myisam表比较多时，使用Questions计算比较准确。当数据库中innodb表比较多时，则以Com_*计算比较准确。\n 5.2 开启慢查询日志\n MySQL开启慢查询日志，分析出哪条SQL语句比较慢，使用set设置变量，重启服务失效，可以在my.cnf添加参数永久生效。\n\n\n\n1234\nmysql&gt; ``set global slow-query-log=on ``#开启慢查询功能``mysql&gt; ``set global slow_query_log_file=``&#39;/var/log/mysql/mysql-slow.log&#39;``; ``#指定慢查询日志文件位置``mysql&gt; ``set global log_queries_not_using_indexes=on;  ``#记录没有使用索引的查询``mysql&gt; ``set global long_query_time=1;  ``#只记录处理时间1s以上的慢查询\n\n\n\n\n\n\n\n 分析慢查询日志，可以使用MySQL自带的mysqldumpslow工具，分析的日志较为简单。\n # mysqldumpslow -t 3 /var/log/mysql/mysql-slow.log   #查看最慢的前三个查询\n 也可以使用percona公司的pt-query-digest工具，日志分析功能全面，可分析slow log、binlog、general log。\n 分析慢查询日志：pt-query-digest /var/log/mysql/mysql-slow.log\n 分析binlog日志：mysqlbinlog mysql-bin.000001 &gt;mysql-bin.000001.sql \n pt-query-digest –type=binlog mysql-bin.000001.sql \n 分析普通日志：pt-query-digest –type=genlog localhost.log\n 5.3 数据库备份\n 备份数据库是最基本的工作，也是最重要的，否则后果很严重，你懂得！但由于数据库比较大，上百G，往往备份都很耗费时间，所以就该选择一个效率高的备份策略，对于数据量大的数据库，一般都采用增量备份。常用的备份工具有mysqldump、mysqlhotcopy、xtrabackup等，mysqldump比较适用于小的数据库，因为是逻辑备份，所以备份和恢复耗时都比较长。mysqlhotcopy和xtrabackup是物理备份，备份和恢复速度快，不影响数据库服务情况下进行热拷贝，建议使用xtrabackup，支持增量备份。\n Xtrabackup备份工具使用博文：http://lizhenliang.blog.51cto.com/7876557/1612800\n 5.4 数据库修复\n 有时候MySQL服务器突然断电、异常关闭，会导致表损坏，无法读取表数据。这时就可以用到MySQL自带的两个工具进行修复，myisamchk和mysqlcheck。\n myisamchk：只能修复myisam表，需要停止数据库\n 常用参数：\n -f –force   强制修复，覆盖老的临时文件，一般不使用\n -r –recover  恢复模式\n -q –quik   快速恢复\n -a –analyze  分析表\n -o –safe-recover 老的恢复模式，如果-r无法修复，可以使用此参数试试\n -F –fast   只检查没有正常关闭的表\n 快速修复weibo数据库:\n # cd /var/lib/mysql/weibo \n # myisamchk -r -q *.MYI\n mysqlcheck：myisam和innodb表都可以用，不需要停止数据库，如修复单个表，可在数据库后面添加表名，以空格分割\n 常用参数：\n -a  –all-databases  检查所有的库\n -r  –repair  修复表\n -c  –check   检查表，默认选项\n -a  –analyze  分析表\n -o  –optimize 优化表\n -q  –quik  最快检查或修复表\n -F  –fast  只检查没有正常关闭的表\n 快速修复weibo数据库:\n mysqlcheck -r -q -uroot -p123 weibo \n 5.5 另外，查看CPU和I/O性能方法\n #查看CPU性能\n\n #参数-P是显示CPU数，ALL为所有，也可以只显示第几颗CPU\n #查看I/O性能\n\n #参数-m是以M单位显示，默认K\n #%util：当达到100%时，说明I/O很忙。\n #await：请求在队列中等待时间，直接影响read时间。\n I/O极限：IOPS（r/s+w/s）,一般RAID0/10在1200左右。（IOPS，每秒进行读写（I/O）操作次数）\n I/O带宽：在顺序读写模式下SAS硬盘理论值在300M/s左右，SSD硬盘理论值在600M/s左右。\n","slug":"mysql调优","date":"2021-04-02T09:20:11.000Z","categories_index":"","tags_index":"mysql调优","author_index":"Phoenix"},{"id":"328c6de9a77c60ec489332ea5bf01cac","title":"jvm调优","content":"一、JVM内存调优\n对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。\n1.Full GC\n会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。\n2.导致Full GC的原因\n1)*年老代（Tenured）被写满*\n调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。\n2)持久代Pemanet Generation空间不足\n增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例\n3)System.gc()被显示调用\n垃圾回收不要手动触发，尽量依靠JVM自身的机制\n在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节，下面详细介绍对应JVM调优的方法和步骤。\n二、JVM性能调优方法和步骤\n1.监控GC的状态\n使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。\n举一个例子： 系统崩溃前的一些现象：\n\n每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s\nFullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC\n年老代的内存越来越大并且每次FullGC后年老代没有内存被释放\n\n之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。\n2.生成堆的dump文件\n通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。\n3.分析dump文件\n打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux，几种工具打开该文件：\n\nVisual VM\nIBM HeapAnalyzer\nJDK 自带的Hprof工具\nMat(Eclipse专门的静态内存分析工具)推荐使用\n\n备注：文件太大，建议使用Eclipse专门的静态内存分析工具Mat打开分析。\n4.分析结果，判断是否需要优化\n如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。\n注：如果满足下面的指标，则一般不需要进行GC：\n\nMinor GC执行时间不到50ms；\nMinor GC执行不频繁，约10秒一次；\nFull GC执行时间不到1s；\nFull GC执行频率不算频繁，不低于10分钟1次；\n\n5.调整GC类型和内存分配\n如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。\n6.不断的分析和调整\n通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。\n\ncms参数优化步流程\n下面我再继续介绍下JVM的关键参数配置(仅用于参考)。\nJVM调优参数参考1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;\n2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。\n比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。\n3.年轻代和年老代设置多大才算合理\n1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC\n2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率\n如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。\n在抉择时应该根 据以下两点：\n（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。\n（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。\n4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。\n5.线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。\n理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\n","slug":"jvm调优","date":"2021-04-02T08:49:16.000Z","categories_index":"","tags_index":"jvm调优","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"title: tomcat调优date: 2021-04-02 16:46:34tags: tomcat调优\n一、描述最近，在补充自己的短板，刚好整理到 Tomcat 调优这块，基本上面试必问，于是就花了点时间去搜集一下 Tomcat 调优都调了些什么，先记录一下调优手段，更多详细的原理和实现以后用到时候再来补充记录，下面就来介绍一下，Tomcat 调优大致分为两大类。\n1、Tomcat的自身调优采用动静分离节约 Tomcat 的性能\n调整 Tomcat 的线程池\n调整 Tomcat 的连接器\n修改 Tomcat 的运行模式\n禁用 AJP 连接器\n2、JVM的调优调优jvm内存\n二、Tomcat 自身调优1、采用动静分离静态资源如果让 Tomcat 处理的话 Tomcat 的性能会被损耗很多，所以我们一般都是采用：Nginx+Tomcat 实现动静分离，让 Tomcat 只负责 jsp 文件的解析工作，Nginx 实现静态资源的访问。\n2、调优 Tomcat 线程池打开tomcat的serve.xml，配置Executor，相关参数说明如下。\n\nname：给执行器（线程池）起一个名字；\nnamePrefix：指定线程池中的每一个线程的 name 前缀；\nmaxThreads：线程池中最大的线程数量，假设请求的数量超过了 750，这将不是意味着将 maxThreads 属性值设置为 750，它的最好解决方案是使用「Tomcat集群」。也就是说，如果有 1000 请求，两个 Tomcat 实例设置 maxThreads = 500，而不在单 Tomcat 实例的情况下设置 maxThreads=1000。\nminSpareThreads：线程池中允许空闲的线程数量（多余的线程都杀死）；\nmaxIdLeTime：一个线程空闲多久算是一个空闲线程；\n其他的配置其实阅读官方文档是最好的「见参考链接」。\n3、调优 Tomcat 的连接器 Connector打开 Tomcat 的 serve.xml，配置 Connector，参数说明如下。\n\nexecutor：指定这个连接器所使用的执行器（线程池）；\n\nenableLookups=false：关闭 DNS 解析，减少性能损耗；\nminProcessors：服务器启动时创建的最少线程数；\nmaxProcessors：最大可以创建的线程数；\nacceptCount=1000：线程池中的线程都被占用，允许放到队列中的请求数；\nmaxThreads=3000：最大线程数；\nminSpareThreads=20：最小空闲线程数，这里是一直会运行的线程；\n与压缩有关系的配置：如果已经对代码进行了动静分离，静态页面和图片等数据就不需要 Tomcat 处理了，那么也就不需要配置在 Tomcat 中配置压缩了；\n一个完整的配置如下。\n\n4、通过修改 Tomcat 的运行模式BIO\nTomcat8 以下版本，默认使用的就是 BIO「阻塞式IO)」模式。\n\n对于每一个请求都要创建一个线程来进行处理，不适合高并发。\nNIO\nTomcat8 以上版本，默认使用的就是NIO模式「非阻塞式 IO」。\nAPR\n全称 Apache Portable Runtime，是Tomcat生产环境运行的首选方式，如果操作系统未安装 APR 或者 APR 路径未指到 Tomcat 默认可识别的路径，则 APR 模式无法启动，自动切换启动 NIO 模式。所以必须要安装 APR 和 Native，直接启动就支持 APR，APR是从操作系统级别解决异步 IO 问题，APR 的本质就是使用 JNI 技术调用操作系统底层的 IO 接口，所以需要提前安装所需要的依赖\n提升 Tomcat 对静态文件的处理性能，当然也可以采用动静分离。\n5、禁用 AJP 连接器AJP的全称 Apache JServer Protocol，使用 Nginx+Tomca t的架构，所以用不着 AJP 协议，所以把AJP连接器禁用。\n\n三、JVM 调优\nTomcat 是运行在 JVM 上的，所以对 JVM 的调优也是非常有必要的。\n找到 catalina.sh；\n\n添加；\n\n参数设置；\n\nJAVA_OPTS=”-Djava.awt.headless=true -Dfile.encoding=UTF-8-server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XXermSize=512m -XX:MaxPermSize=512m -XX:+DisableExplicitGC”\n\n调整堆大小的的目的是最小化垃圾收集的时间，以在特定的时间内最大化处理客户的请求。\n参考\nhttps://tomcat.apache.org/tomcat-8.0-doc/config/executor.html\nhttps://tomcat.apache.org/tomcat-8.0-doc/config/index.html\n","slug":"tomcat调优","date":"2021-04-02T08:46:34.916Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"94cb37335dcf3a428e4a1d020fa13c9d","title":"Linux性能调优","content":"一、前提我们可以在文章的开始就列出一个列表，列出可能影响Linux操作系统性能的一些调优参数，但这样做其实并没有什么价值。因为性能调优是一个非常困难的任务，它要求对硬件、操作系统、和应用都有着相当深入的了解。如果性能调优非常简单的话，那些我们要列出的调优参数早就写入硬件的微码或者操作系统中了，我们就没有必要再继续读这篇文章了。正如下图所示，服务器的性能受到很多因素的影响。\n\n当面对一个使用单独IDE硬盘的，有20000用户的数据库服务器时，即使我们使用数周时间去调整I/O子系统也是徒劳无功的，通常一个新的驱动或者应用程序的一个更新（如SQL优化）却可以使这个服务器的性能得到明显的提升。正如我们前面提到的，不要忘记系统的性能是受多方面因素影响的。理解操作系统管理系统资源的方法将帮助我们在面对问题时更好的判断应该对哪个子系统进行调整。\n二、Linux的CPU调度任何计算机的基本功能都十分简单，那就是计算。为了实现计算的功能就必须有一个方法去管理计算资源、处理器和计算任务（也被叫做线程或者进程）。非常感谢Ingo Molnar，他为Linux内核带来了O（1）CPU调度器，区别于旧有的O（n）调度器，新的调度器是动态的，可以支持负载均衡，并以恒定的速度进行操作。\n新调度器的可扩展性非常好，无论进程数量或者处理器数量，并且调度器本身的系统开销更少。新调取器的算法使用两个优先级队列。\n・活动运行队列\n・过期运行队列\n调度器的一个重要目标是根据优先级权限有效地为进程分配CPU 时间片，当分配完成后它被列在CPU的运行队列中，除了 CPU 的运行队列之外，还有一个过期运行队列。当活动运行队列中的一个任务用光自己的时间片之后，它就被移动到过期运行队列中。在移动过程中，会对其时间片重新进行计算。如果活动运行队列中已经没有某个给定优先级的任务了，那么指向活动运行队列和过期运行队列的指针就会交换，这样就可以让过期优先级列表变成活动优先级的列表。通常交互式进程（相对与实时进程而言）都有一个较高的优先级，它占有更长的时间片，比低优先级的进程获得更多的计算时间，但通过调度器自身的调整并不会使低优先级的进程完全被饿死。新调度器的优势是显著的改变Linux内核的可扩展性，使新内核可以更好的处理一些有大量进程、大量处理器组成的企业级应用。新的O(1)调度器包含仔2.6内核中，但是也向下兼容2.4内核。\n\n调度器另外一个重要的优势是体现在对NUMA(non-uniform memory architecture)和SMP（symmetric multithreading processors）的支持上，例如INTEL@的超线程技术\n改进的NUMA支持保证了负载均衡不会发生在CECs或者NUMA节点之间，除非发生一个节点的超出负载限度\n三、Linux的内存架构今天我们面对选择32位操作系统还是64位操作系统的情况。对企业级用户它们之间最大的区别是64位操作系统可以支持大于4GB的内存寻址。从性能角度来讲，我们需要了解32位和64位操作系统都是如何进行物理内存和虚拟内存的映射的。\n\n在上面图示中我们可以看到64位和32位Linux内核在寻址上有着显著的不同。\n在32位架构中，比如IA-32，Linux内核可以直接寻址的范围只有物理内存的第一个GB（如果去掉保留部分还剩下896MB），访问内存必须被映射到这小于1GB的所谓ZONE_NORMAL空间中，这个操作是由应用程序完成的。但是分配在ZONE_HIGHMEM中的内存页将导致性能的降低。\n在另一方面，64位架构比如x86-64（也称作EM64T或者AMD64）。ZONE_NORMAL空间将扩展到64GB或者128GB（实际上可以更多，但是这个数值受到操作系统本身支持内存容量的限制）。正如我们看到的，使用64位操作系统我们排除了因ZONE_HIGHMEM部分内存对性能的影响的情况。\n实际中，在32位架构下，由于上面所描述的内存寻址问题，对于大内存，高负载应用，会导致死机或严重缓慢等问题。虽然使用hugemen核心可缓解，但采取x86_64架构是最佳的解决办法。\n四、虚拟内存管理因为操作系统将内存都映射为虚拟内存，所以操作系统的物理内存结构对用户和应用来说通常都是不可见的。如果想要理解Linux系统内存的调优，我们必须了解Linux的虚拟内存机制。应用程序并不分配物理内存，而是向Linux内核请求一部分映射为虚拟内存的内存空间。如下图所示虚拟内存并不一定是映射物理内存中的空间，如果应用程序有一个大容量的请求，也可能会被映射到在磁盘子系统中的swap空间中。\n\n另外要提到的是，通常应用程序不直接将数据写到磁盘子系统中，而是写入缓存和缓冲区中。Bdflush守护进程将定时将缓存或者缓冲区中的数据写到硬盘上。\nLinux内核处理数据写入磁盘子系统和管理磁盘缓存是紧密联系在一起的。相对于其他的操作系统都是在内存中分配指定的一部分作为磁盘缓存，Linux处理内存更加有效，默认情况下虚拟内存管理器分配所有可用内存空间作为磁盘缓存，这就是为什么有时我们观察一个配置有数G内存的Linux系统可用内存只有20MB的原因。\n同时Linux使用swap空间的机制也是相当高效率的，如上图所示虚拟内存空间是由物理内存和磁盘子系统中的swap空间共同组成的。如果虚拟内存管理器发现一个已经分配完成的内存分页已经长时间没有被调用，它将把这部分内存分页移到swap空间中。经常我们会发现一些守护进程，比如getty，会随系统启动但是却很少会被应用到。这时为了释放昂贵的主内存资源，系统会将这部分内存分页移动到swap空间中。上述就是Linux使用swap空间的机制，当swap分区使用超过50％时，并不意味着物理内存的使用已经达到瓶颈了，swap空间只是Linux内核更好的使用系统资源的一种方法。\n简单理解：Swap usage只表示了Linux管理内存的有效性。对识别内存瓶颈来说，Swap In/Out才是一个比较又意义的依据，如果Swap In/Out的值长期保持在每秒200到300个页面通常就表示系统可能存在内存的瓶颈。下面的事例是好的状态：\n\n五、模块化的I/O调度器就象我们知道的Linux2.6内核为我们带来了很多新的特性，这其中就包括了新的I/O调度机制。旧的2.4内核使用一个单一的I/O调度器，2.6 内核为我们提供了四个可选择的I/O调度器。因为Linux系统应用在很广阔的范围里，不同的应用对I/O设备和负载的要求都不相同，例如一个笔记本电脑和一个10000用户的数据库服务器对I/O的要求肯定有着很大的区别。\n（1）Anticipatory\nanticipatory I/O调度器创建假设一个块设备只有一个物理的查找磁头（例如一个单独的SATA硬盘），正如anticipatory调度器名字一样，anticipatory调度器使用“anticipatory”的算法写入硬盘一个比较大的数据流代替写入多个随机的小的数据流，这样有可能导致写 I/O操作的一些延时。这个调度器适用于通常的一些应用，比如大部分的个人电脑。\n（2）Complete Fair Queuing (CFQ)\nComplete Fair Queuing（CFQ）调度器是Red Flag DC Server 5使用的标准算法。CFQ调度器使用QoS策略为系统内的所有任务分配相同的带宽。CFQ调度器适用于有大量计算进程的多用户系统。它试图避免进程被饿死和实现了比较低的延迟。\n（3）Deadline\ndeadline调度器是使用deadline算法的轮询的调度器，提供对I/O子系统接近实时的操作，deadline调度器提供了很小的延迟和维持一个很好的磁盘吞吐量。如果使用deadline算法请确保进程资源分配不会出现问题。\n（4）NOOP\nNOOP调度器是一个简化的调度程序它只作最基本的合并与排序。与桌面系统的关系不是很大，主要用在一些特殊的软件与硬件环境下，这些软件与硬件一般都拥有自己的调度机制对内核支持的要求很小，这很适合一些嵌入式系统环境。作为桌面用户我们一般不会选择它。\n六、网络子系统新的网络中断缓和（NAPI）对网络子系统带来了改变，提高了大流量网络的性能。Linux内核在处理网络堆栈时，相比降低系统占用率和高吞吐量更关注可靠性和低延迟。所以在某些情况下，Linux建立一个防火墙或者文件、打印、数据库等企业级应用的性能可能会低于相同配置的Windows服务器。\n在传统的处理网络封包的方式中，如下图蓝色箭头所描述的，一个以太网封包到达网卡接口后，如果MAC地址相符合会被送到网卡的缓冲区中。网卡然后将封包移到操作系统内核的网络缓冲区中并且对CPU发出一个硬中断，CPU会处理这个封包到相应的网络堆栈中，可能是一个TCP端口或者Apache应用中。\n\n这是一个处理网络封包的简单的流程，但从中我们可以看到这个处理方式的缺点。正如我们看到的，每次适合网络封包到达网络接口都将对CPU发出一个硬中断信号，中断CPU正在处理的其他任务，导致切换动作和对CPU缓存的操作。你可能认为当只有少量的网络封包到达网卡的情况下这并不是个问题，但是千兆网络和现代的应用将带来每秒钟成千上万的网络数据，这就有可能对性能造成不良的影响。\n正是因为这个情况，NAPI在处理网络通讯的时候引入了计数机制。对第一个封包，NAPI以传统的方式进行处理，但是对后面的封包，网卡引入了POLL 的轮询机制：如果一个封包在网卡DMA环的缓存中，就不再为这个封包申请新的中断，直到最后一个封包被处理或者缓冲区被耗尽。这样就有效的减少了因为过多的中断CPU对系统性能的影响。同时，NAPI通过创建可以被多处理器执行的软中断改善了系统的可扩展性。NAPI将为大量的企业级多处理器平台带来帮助，它要求一个启用NAPI的驱动程序。在今天很多驱动程序默认没有启用NAPI，这就为我们调优网络子系统的性能提供了更广阔的空间。\n七、理解Linux调优参数因为Linux是一个开源操作系统，所以又大量可用的性能监测工具。对这些工具的选择取决于你的个人喜好和对数据细节的要求。所有的性能监测工具都是按照同样的规则来工作的，所以无论你使用哪种监测工具都需要理解这些参数。下面列出了一些重要的参数，有效的理解它们是很有用处的。\n（1）处理器参数\n・CPU utilization\n这是一个很简单的参数，它直观的描述了每个CPU的利用率。在xSeries架构中，如果CPU的利用率长时间的超过80％，就可能是出现了处理器的瓶颈。\n・Runable processes\n这个值描述了正在准备被执行的进程，在一个持续时间里这个值不应该超过物理CPU数量的10倍，否则CPU方面就可能存在瓶颈。\n・Blocked\n描述了那些因为等待I/O操作结束而不能被执行的进程，Blocked可能指出你正面临I/O瓶颈。\n・User time\n描述了处理用户进程的百分比，包括nice time。如果User time的值很高，说明系统性能用在处理实际的工作。\n・System time\n描述了CPU花费在处理内核操作包括IRQ和软件中断上面的百分比。如果system time很高说明系统可能存在网络或者驱动堆栈方面的瓶颈。一个系统通常只花费很少的时间去处理内核的操作。\n・Idle time\n描述了CPU空闲的百分比。\n・Nice time\n描述了CPU花费在处理re-nicing进程的百分比。\n・Context switch\n系统中线程之间进行交换的数量。\n・Waiting\nCPU花费在等待I/O操作上的总时间，与blocked相似，一个系统不应该花费太多的时间在等待I/O操作上，否则你应该进一步检测I/O子系统是否存在瓶颈。\n・Interrupts\nInterrupts 值包括硬Interrupts和软Interrupts，硬Interrupts会对系统性能带来更多的不利影响。高的Interrupts值指出系统可能存在一个软件的瓶颈，可能是内核或者驱动程序。注意Interrupts值中包括CPU时钟导致的中断（现代的xServer系统每秒1000个 Interrupts值）。\n（2）内存参数\n・Free memory\n相比其他操作系统，Linux空闲内存的值不应该做为一个性能参考的重要指标，因为就像我们之前提到过的，Linux内核会分配大量没有被使用的内存作为文件系统的缓存，所以这个值通常都比较小。\n・Swap usage\n这 个值描述了已经被使用的swap空间。Swap usage只表示了Linux管理内存的有效性。对识别内存瓶颈来说，Swap In/Out才是一个比较又意义的依据，如果Swap In/Out的值长期保持在每秒200到300个页面通常就表示系统可能存在内存的瓶颈。\n・Buffer and cache\n这个值描述了为文件系统和块设备分配的缓存。在Red Flag DC Server 5版本中,你可以通过修改/proc/sys/vm中的page_cache_tuning来调整空闲内存中作为缓存的数量。\n・Slabs\n描述了内核使用的内存空间，注意内核的页面是不能被交换到磁盘上的。\n・Active versus inactive memory\n提供了关于系统内存的active内存信息，Inactive内存是被kswapd守护进程交换到磁盘上的空间。\n（3）网络参数\n・Packets received and sent\n这个参数表示了一个指定网卡接收和发送的数据包的数量。\n・Bytes received and sent\n这个参数表示了一个指定网卡接收和发送的数据包的字节数。\n・Collisions per second\n这个值提供了发生在指定网卡上的网络冲突的数量。持续的出现这个值代表在网络架构上出现了瓶颈，而不是在服务器端出现的问题。在正常配置的网络中冲突是非常少见的，除非用户的网络环境都是由hub组成。\n・Packets dropped\n这个值表示了被内核丢掉的数据包数量，可能是因为防火墙或者是网络缓存的缺乏。\n・Overruns\nOverruns表达了超出网络接口缓存的次数，这个参数应该和packets dropped值联系到一起来判断是否存在在网络缓存或者网络队列过长方面的瓶颈。\n・Errors 这个值记录了标志为失败的帧的数量。这个可能由错误的网络配置或者部分网线损坏导致，在铜口千兆以太网环境中部分网线的损害是影响性能的一个重要因素。\n（4）块设备参数\n・Iowait\nCPU等待I/O操作所花费的时间。这个值持续很高通常可能是I/O瓶颈所导致的。\n・Average queue length\nI/O请求的数量，通常一个磁盘队列值为2到3为最佳情况，更高的值说明系统可能存在I/O瓶颈。\n・Average wait\n响应一个I/O操作的平均时间。Average wait包括实际I/O操作的时间和在I/O队列里等待的时间。\n・Transfers per second\n描述每秒执行多少次I/O操作（包括读和写）。Transfers per second的值与kBytes per second结合起来可以帮助你估计系统的平均传输块大小，这个传输块大小通常和磁盘子系统的条带化大小相符合可以获得最好的性能。\n・Blocks read/write per second\n这个值表达了每秒读写的blocks数量，在2.6内核中blocks是1024bytes，在早些的内核版本中blocks可以是不同的大小，从512bytes到4kb。\n・Kilobytes per second read/write\n按照kb为单位表示读写块设备的实际数据的数量。\n","slug":"Linux性能调优","date":"2021-04-02T08:20:57.000Z","categories_index":"","tags_index":"Linux","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"全注解下的spring iocspring最成功的便是其提出的两个理念 （ IOC和AOP) 控制反转和面向切面编程。\n其中ioc容器思想是spring的核心，而spring是基于注解开发的spring ioc 所以重点分析全注解下的spring ioc。\nIoC是一种通过描述来生成或者获取对象的技术，而这个技术不是Spring甚至不是Java独有的。对于Java初学者更多的时候所熟悉的是使用new关键字来创建对象，而在Spring中则不是，它是通过描述来创建对象。只是Spring Boot并不建议使用XML，而是通过注解的描述生成对象。\n一个系统可以生成各种对象，并且这些对象都需要进行管理。值得一提的事，对象之间并不孤立，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成，那么班级就依赖于多个老师和同学。为了解藕，spring还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。\n而为了描述上述班级、同学和老师这三个对象关系，我们需要一个容器。在spring中把每一个需要管理的对象称为spring bean，而spring管理这些bean的容器，被我们称为spring ioc容器（或者简称ioc容器）。ioc容器需要具备两个基本功能：\n\n通过描述管理bean，包括发布和获取bean；\n\n通过描述完成bean之间的依赖关系。\n\n\nioc容器分析ioc是一个管理bean的容器，在spring的定义中，它要求所有的ioc容器都需要实现接口beanfactory，它是一个顶级容器接口。\nbeanfactory接口源码分析：\n装配Bean在spring中允许我们通过xml或者Java配置文件装配bean，但是由于spring boot是基于注解的方式，因此下面主要基于注解的方式来介绍spring的用法，以满足spring boot开发者的需要。\n自动扫描装配Bean如果一个个的bean使用注解@Bean注入spring ioc容器中，那将是一件很麻烦的事情。好在spring还允许我们进行扫描装配bean到ioc容器中，对于扫描装配而言使用的注解是@Component和@componentSca。@Component是标明哪个类被扫描进入spring ioc容器，而@ComponentScan则是标明采用何种策略去扫描装配Bean。\n@Componente\npublic class User&#123;\n\t@Value(\"1\")\n\tprivate Long id;\n\t@Value(\"user_name_1\")\n\tprivate String userName;\n\t@Value(\"note_1\")\n\tprivate String note;\n\t/** some code about getter and setter**/\n&#125;\n\n这里的注解**@Component表明这个类将被Spring IoC容器扫描装配，其中配置的“user”则是作为Bean的名称，当然你也可以不配置这个字符串，那么IoC容器就会把类名第一个字母作为小写，其他不变作为Bean名称放入到IoC容器中；注解@Value则是指定具体的值，使得Spring IoC给予对应的属性注入对应的值**。为了让Spring IoC容器装配这个类，需要改造类AppConfig，如代码清单3-6所示。\n@Configuration\n@ComponentScan\npublic class AppConfig&#123;&#125;\n\n这里加入@ComponentScan,意味着它会进行扫描，但是它只会扫描类AppConfig所在的当前包和其子包，之前把User.java移到包com.springboot.chapter3.config就是这个原因。这样就可以删掉之前使用@Bean标注的创建对象方法。然后进行测试，测试代码如下：\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\nUser user = ctx.getBean(User.class);\nlog.info(user.getId());\n\n","slug":"深入浅出springboot2有感","date":"2021-04-01T09:23:17.000Z","categories_index":"","tags_index":"spring boot","author_index":"Phoenix"},{"id":"9da32cf7dee442ab70933258c7f0a51d","title":"servlet","content":"古老的技术Servlettomcattomcat是一个web服务器（同时也是servlet容器），通过它我们可以很方便地接收和返回到请求（如果不用tomcat，那我们需要自己写socket来接收和返回请求）。\n各个目录的含义：\nbin：存放启动和关闭tomcat的脚本文件\nconf：存放tomcat服务器的各种配置文件\nlib：存放tomcat服务器的支撑jar包\nlogs：存放tomcat的日志文件\ntemp：存放tomcat运行时产生的临时文件\nwebapps：web应用所在目录，即供外界访问的web资源的存放目录。\nwork：tomcat工作目录\nServlet版”hello world”首先，我们需要认清一个JavaWeb的标准目录结构：\nwebapps–&gt;bbs(web应用目录)–&gt;html文件，jsp文件\n​                                                     –&gt;web-inf目录–&gt;web.xml、taolib.tld\n​                                                                               –&gt;classes目录–&gt;类的包目录–&gt;各种class文件标签处理类\n​                                                    –&gt;lib目录（web应用需要的jar包）\nservlet案例","slug":"servlet","date":"2021-04-01T08:03:01.000Z","categories_index":"","tags_index":"java","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"今日内容1. web概念概述\n2. HTML\n\nweb概念概述* JavaWeb：\n    * 使用Java语言开发基于互联网的项目\n\n* 软件架构：\n    1. C/S: Client/Server 客户端/服务器端\n        * 在用户本地有一个客户端程序，在远程有一个服务器端程序\n        * 如：QQ，迅雷...\n        * 优点：\n            1. 用户体验好\n        * 缺点：\n            1. 开发、安装，部署，维护 麻烦\n    2. B/S: Browser/Server 浏览器/服务器端\n        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序\n        * 优点：\n            1. 开发、安装，部署，维护 简单\n        * 缺点：\n            1. 如果应用过大，用户的体验可能会受到影响\n            2. 对硬件要求过高\n\n* B/S架构详解\n    * 资源分类：\n        1. 静态资源：\n            * 使用静态网页开发技术发布的资源。\n            * 特点：\n                * 所有用户访问，得到的结果是一样的。\n                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript\n                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源\n        2. 动态资源：\n            * 使用动态网页及时发布的资源。\n            * 特点：\n                * 所有用户访问，得到的结果可能不一样。\n                * 如：jsp/servlet,php,asp...\n                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器\n\n\n    * 我们要学习动态资源，必须先学习静态资源！\n\n    * 静态资源：\n        * HTML：用于搭建基础网页，展示页面的内容\n        * CSS：用于美化页面，布局页面\n        * JavaScript：控制页面的元素，让页面有一些动态的效果\n\nHTML1. 概念：是最基础的网页开发语言\n\t* Hyper Text Markup Language 超文本标记语言\n\t\t* 超文本:\n\t\t\t* 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.\n\t\t* 标记语言:\n\t\t\t* 由标签构成的语言。&lt;标签名称> 如 html，xml\n\t\t\t* 标记语言不是编程语言\n\n2. 快速入门：\n\t* 语法：\n\t\t1. html文档后缀名 .html 或者 .htm\n\t\t2. 标签分为\n\t\t\t1. 围堵标签：有开始标签和结束标签。如 &lt;html> &lt;/html>\n\t\t\t2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/>\n\n\t\t3. 标签可以嵌套：\n\t\t\t需要正确嵌套，不能你中有我，我中有你\n\t\t\t错误：&lt;a>&lt;b>&lt;/a>&lt;/b>\n\t\t\t正确：&lt;a>&lt;b>&lt;/b>&lt;/a>\n\n\t\t4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来\n\t\t5. html的标签不区分大小写，但是建议使用小写。\n\n\t* 代码：\n\t\t&lt;html>\n\t\t\n\t\t\t&lt;head>\n\t\t\t\t&lt;title>title&lt;/title>\n\t\t\t&lt;/head>\n\t\t\t\n\t\t\t&lt;body>\n\t\t\t\t&lt;FONT color='red'>Hello World&lt;/font>&lt;br/>\n\t\t\t\t\n\t\t\t\t&lt;font color='green'>Hello World&lt;/font>\n\t\t\t\n\t\t\t&lt;/body>\n\t\n\t\t&lt;/html>\n\n3. 标签学习：\n\t1. 文件标签：构成html最基本的标签\n\t\t* html:html文档的根标签\n\t\t* head：头标签。用于指定html文档的一些属性。引入外部的资源\n\t\t* title：标题标签。\n\t\t* body：体标签\n\t\t* &lt;!DOCTYPE html>：html5中定义该文档是html文档\n\t2. 文本标签：和文本有关的标签\n\t\t* 注释：&lt;!-- 注释内容 -->\n\t\t* &lt;h1> to &lt;h6>：标题标签\n\t\t\t* h1~h6:字体大小逐渐递减\n\t\t* &lt;p>：段落标签\n\t\t* &lt;br>：换行标签\n\t\t* &lt;hr>：展示一条水平线\n\t\t\t* 属性：\n\t\t\t\t* color：颜色\n\t\t\t\t* width：宽度\n\t\t\t\t* size：高度\n\t\t\t\t* align：对其方式\n\t\t\t\t\t* center：居中\n\t\t\t\t\t* left：左对齐\n\t\t\t\t\t* right：右对齐\n\t\t* &lt;b>：字体加粗\n\t\t* &lt;i>：字体斜体 \n\t\t* &lt;font>:字体标签\n\t\t* &lt;center>:文本居中\n\t\t\t* 属性：\n\t\t\t\t* color：颜色\n\t\t\t\t* size：大小\n\t\t\t\t* face：字体\n\n\t\t* 属性定义：\n\t\t\t* color：\n\t\t\t\t1. 英文单词：red,green,blue\n\t\t\t\t2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)\n\t\t\t\t3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF\n\t\t\t* width：\n\t\t\t\t1. 数值：width='20' ,数值的单位，默认是 px(像素)\n\t\t\t\t2. 数值%：占比相对于父元素的比例\n\n\t\t* 案例：公司简介\n\t\t\t&lt;!DOCTYPE html>\n\t\t\t&lt;html lang=\"ch\">\n\t\t\t&lt;head>\n\t\t\t    &lt;meta charset=\"UTF-8\">\n\t\t\t    &lt;title>黑马程序员简介&lt;/title>\n\t\t\t&lt;/head>\n\t\t\t&lt;body>\n\t\t\t\n\t\t\t&lt;h1>\n\t\t\t    公司简介\n\t\t\t&lt;/h1>\n\t\t\t&lt;hr color=\"#ffd700\">\n\t\t\t\n\t\t\t&lt;p>\n\t\t\t&lt;font color=\"#FF0000\">\"中关村黑马程序员训练营\"&lt;/font>是由&lt;b>&lt;i>传智播客&lt;/i>&lt;/b>联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。\n\t\t\t&lt;/p>\n\t\t\t\n\t\t\t&lt;p>\n\t\t\t目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。\n\t\t\t&lt;/p>\n\t\t\t\n\t\t\t&lt;p>\n\t\t\t\n\t\t\t黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。\n\t\t\t中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。\n\t\t\t&lt;/p>\n\t\t\t\n\t\t\t&lt;p>\n\t\t\t\n\t\t\t一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。\n\t\t\t&lt;/p>\n\t\t\t\n\t\t\t&lt;hr color=\"#ffd700\">\n\t\t\t\n\t\t\t&lt;font color=\"gray\" size=\"2\">\n\t\t\t    &lt;center>\n\t\t\t        江苏传智播客教育科技股份有限公司&lt;br>\n\t\t\t        版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882\n\t\t\t    &lt;/center>\n\t\t\t&lt;/font>\n\n\n​​                                \n    3. 图片标签：\n        * img：展示图片\n            * 属性：\n                * src：指定图片的位置\n\n        * 代码：\n             &lt;!--展示一张图片 img--&gt;\n\n            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;\n        \n            &lt;!--\n                相对路径\n                    * 以.开头的路径\n                        * ./：代表当前目录  ./image/1.jpg\n                        * ../:代表上一级目录\n             --&gt;\n        \n            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;\n        \n            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;\n    4. 列表标签：\n        * 有序列表：\n            * ol:\n            * li:\n        * 无序列表：\n            * ul:\n            * li:\n    5. 链接标签：\n        * a:定义一个超链接\n            * 属性：\n                * href：指定访问资源的URL(统一资源定位符)\n                * target：指定打开资源的方式\n                    * _self:默认值，在当前页面打开\n                    * _blank：在空白页面打开\n\n        * 代码：\n             &lt;!--超链接  a--&gt;\n\n            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;\n            &lt;br&gt;\n        \n            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;\n            &lt;br&gt;\n            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;\n        \n            &lt;br&gt;\n        \n            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;\n            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;\n        \n            &lt;br&gt;\n            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;\n    6. div和span：\n        * div:每一个div占满一整行。块级标签\n        * span：文本信息在一行展示，行内标签 内联标签\n\n    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。\n        1. &lt;header&gt;：页眉\n        2. &lt;footer&gt;：页脚\n\n\n    8. 表格标签：\n        * table：定义表格\n            * width：宽度\n            * border：边框\n            * cellpadding：定义内容和单元格的距离\n            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、\n            * bgcolor：背景色\n            * align：对齐方式\n        * tr：定义行\n            * bgcolor：背景色\n            * align：对齐方式\n        * td：定义单元格\n            * colspan：合并列\n            * rowspan：合并行\n        * th：定义表头单元格\n        * &lt;caption&gt;：表格标题\n        * &lt;thead&gt;：表示表格的头部分\n        * &lt;tbody&gt;：表示表格的体部分\n        * &lt;tfoot&gt;：表示表格的脚部分\n\n案例：旅游网站首页1. 确定使用table来完成布局    \n2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n3. 如果某一行有多个单元格，则使用\n    &lt;tr&gt;\n        &lt;td&gt;\n            &lt;table&gt;&lt;/table&gt;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n\n4. 代码实现\n\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;黑马旅游网&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    \n        &lt;!--采用table来完成布局--&gt;\n        &lt;!--最外层的table，用于整个页面的布局--&gt;\n        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;\n           &lt;!-- 第1行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第2行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;\n                        &lt;tr&gt;\n                            &lt;td&gt;\n                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/table&gt;\n    \n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第3行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;\n                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;\n                            &lt;td&gt;\n                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n                                门票\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/table&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第4行 轮播图 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第5行 黑马精选--&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;\n                    黑马精选\n                    &lt;hr  color=&quot;#ffd700&quot; &gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第6行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;\n                        &lt;tr&gt;\n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/table&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第7行 国内游 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;\n                    国内游\n                    &lt;hr  color=&quot;#ffd700&quot; &gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第8行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;\n                        &lt;tr&gt;\n                            &lt;td rowspan=&quot;2&quot;&gt;\n                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n    \n                        &lt;tr&gt;\n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n\n​                                                                                        \n            &lt;!-- 第9行 境外游 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;\n                    境外游\n                    &lt;hr  color=&quot;#ffd700&quot; &gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第10行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;\n                        &lt;tr&gt;\n                            &lt;td rowspan=&quot;2&quot;&gt;\n                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n    \n                        &lt;tr&gt;\n                            &lt;td&gt;\n    \n                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n    \n                            &lt;td&gt;\n    \n                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;\n                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;\n                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;\n                            &lt;/td&gt;\n\n                        &lt;/tr&gt;\n                    &lt;/table&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;!-- 第11行 --&gt;\n            &lt;tr&gt;\n                &lt;td&gt;\n                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n    \n            &lt;!-- 第12行 --&gt;\n            &lt;tr&gt;\n                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;\n                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;\n                    江苏传智播客教育科技股份有限公司\n                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882\n                    &lt;/font&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            \n        &lt;/table&gt;\n\n​                \n","slug":"HTML课堂笔记","date":"2021-03-29T06:32:54.776Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"设计模式概述设计模式代表了最佳的实践，通常被有经验的面相对象的软件开发人员所采用。\n设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多\n软件开大人员经过相当长的一段时间的试验和错误总结出来的。\n\n我的个人总结：工厂模式即是构建接口 利用继承构建多类，然后通过工厂方法实现类的实现，即由原本的new 变成了由工厂的方法产生，多次封装。优点就是隐藏了具体实现而可以更关注逻辑，缺点就是代码量大，但是用框架的就会更简单\n\n\n抽象工厂模式：就是在工厂模式基础上，用工厂生产工厂再由生产的工厂生产类。\n\n\n工厂模式工厂模式是Java中最常用的设计模式之一。__这种类型的设计模式属于创型模式，它提供了一种创建对象的最佳方式。__工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而且通过使用一个共同的借口来指向新创建的对象。\n详细介绍：\n意图：定义一个创建对象的接口，让子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n如何使用：我们明确地计划不同条件下创建不同实例时。\n如何解决：让子类实现工厂接口，返回的也是一个抽象的产品。\n关键代码：创建过程在其子类执行。\n应用实例：\n\n你需要一辆汽车，可以直接从工厂提货，而不用去管汽车怎么实现的。  \nHibernate 换数据只需要换方言和驱动就可以。  \n\n优点:\n一个调用者想创建对象，只需要知道其名称就可以了。\n 扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以。  \n屏蔽产品的具体实现，调用者只关心产品的接口。\n\n缺点：\n每次增加一个产品，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n还是老缺点，就是增加了代码量。\n\n使用场景\n日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 \n数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 \n设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。\n\n注意事项：​        作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n具体实现步骤1. \n创建一个接口\npublic interface Shape &#123;   void draw(); &#125;\n\n步骤2.\n创建实现接口的实体类\npublic class Rectangle implements Shape &#123;\n \n   @Override\n   public void draw() &#123;\n      System.out.println(\"Inside Rectangle::draw() method.\");\n   &#125;\n&#125;\n\npublic class Square implements Shape &#123;\n \n   @Override\n   public void draw() &#123;\n      System.out.println(\"Inside Square::draw() method.\");\n   &#125;\n&#125;\n\npublic class Circle implements Shape &#123;\n \n   @Override\n   public void draw() &#123;\n      System.out.println(\"Inside Circle::draw() method.\");\n   &#125;\n&#125;\n\n步骤3.\n创建一个工厂，生成基于给定信息的实体类的对象\npublic class ShapeFactory &#123;\n    \n   //使用 getShape 方法获取形状类型的对象\n   public Shape getShape(String shapeType)&#123;\n      if(shapeType == null)&#123;\n         return null;\n      &#125;        \n      if(shapeType.equalsIgnoreCase(\"CIRCLE\"))&#123;\n         return new Circle();\n      &#125; else if(shapeType.equalsIgnoreCase(\"RECTANGLE\"))&#123;\n         return new Rectangle();\n      &#125; else if(shapeType.equalsIgnoreCase(\"SQUARE\"))&#123;\n         return new Square();\n      &#125;\n      return null;\n   &#125;\n&#125;\n\n步骤4.\n使用该工厂，通过传递类型信息来获取实体类的对象\npublic class FactoryPatternDemo &#123;\n \n   public static void main(String[] args) &#123;\n      ShapeFactory shapeFactory = new ShapeFactory();\n \n      //获取 Circle 的对象，并调用它的 draw 方法\n      Shape shape1 = shapeFactory.getShape(\"CIRCLE\");\n \n      //调用 Circle 的 draw 方法\n      shape1.draw();\n \n      //获取 Rectangle 的对象，并调用它的 draw 方法\n      Shape shape2 = shapeFactory.getShape(\"RECTANGLE\");\n \n      //调用 Rectangle 的 draw 方法\n      shape2.draw();\n \n      //获取 Square 的对象，并调用它的 draw 方法\n      Shape shape3 = shapeFactory.getShape(\"SQUARE\");\n \n      //调用 Square 的 draw 方法\n      shape3.draw();\n   &#125;\n&#125;\n\n步骤5.\n执行程序，输出结果：\nInside Circle::draw() method.\nInside Rectangle::draw() method.\nInside Square::draw() method.\n\n\n抽象工厂模式​        抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\n介绍\n意图：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。\n主要解决：主要解决接口选择的问题。\n何时使用：系统的产品有多于以一个的产品族，而系统只消费其中某一族的产品。\n如何解决：在一个产品族里面，定义多个产品。\n关键代码：在一个工厂里聚合多个同类产品。\n应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。\n优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用其中同一个产品族中的对象。\n缺点：产品族扩展非常困难，要增加一个系列的某一个产品，既要在抽象的creator里加代码，又要在具体的里面加代码。\n应用场景：1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。\n注意事项：产品族难扩展，产品等级易扩展。\n具体实现\n步骤1 为形状创建一个接口\npublic interface Shape &#123;   void draw(); &#125;\n\n步骤2 创建实现接口的实体类。\npublic class Rectangle implements Shape &#123;    @Override   public void draw() &#123;      System.out.println(\"Inside Rectangle::draw() method.\");   &#125; &#125;\n\npublic class Square implements Shape &#123;\n \n   @Override\n   public void draw() &#123;\n      System.out.println(\"Inside Square::draw() method.\");\n   &#125;\n&#125;\n\npublic class Circle implements Shape &#123;\n \n   @Override\n   public void draw() &#123;\n      System.out.println(\"Inside Circle::draw() method.\");\n   &#125;\n&#125;\n\n步骤3 为颜色创建一个接口\npublic class Red implements Color &#123;\n \n   @Override\n   public void fill() &#123;\n      System.out.println(\"Inside Red::fill() method.\");\n   &#125;\n&#125;\n\npublic class Green implements Color &#123;\n \n   @Override\n   public void fill() &#123;\n      System.out.println(\"Inside Green::fill() method.\");\n   &#125;\n&#125;\n\npublic class Blue implements Color &#123;\n \n   @Override\n   public void fill() &#123;\n      System.out.println(\"Inside Blue::fill() method.\");\n   &#125;\n&#125;\n\n步骤5 为 Color 和 Shape 对象创建抽象类来获取工厂。\npublic abstract class AbstractFactory &#123;\n   public abstract Color getColor(String color);\n   public abstract Shape getShape(String shape) ;\n&#125;\n\n步骤6 创建扩展了AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。\npublic class ShapeFactory extends AbstractFactory &#123;\n    \n   @Override\n   public Shape getShape(String shapeType)&#123;\n      if(shapeType == null)&#123;\n         return null;\n      &#125;        \n      if(shapeType.equalsIgnoreCase(\"CIRCLE\"))&#123;\n         return new Circle();\n      &#125; else if(shapeType.equalsIgnoreCase(\"RECTANGLE\"))&#123;\n         return new Rectangle();\n      &#125; else if(shapeType.equalsIgnoreCase(\"SQUARE\"))&#123;\n         return new Square();\n      &#125;\n      return null;\n   &#125;\n   \n   @Override\n   public Color getColor(String color) &#123;\n      return null;\n   &#125;\n&#125;\n\npublic class ColorFactory extends AbstractFactory &#123;\n    \n   @Override\n   public Shape getShape(String shapeType)&#123;\n      return null;\n   &#125;\n   \n   @Override\n   public Color getColor(String color) &#123;\n      if(color == null)&#123;\n         return null;\n      &#125;        \n      if(color.equalsIgnoreCase(\"RED\"))&#123;\n         return new Red();\n      &#125; else if(color.equalsIgnoreCase(\"GREEN\"))&#123;\n         return new Green();\n      &#125; else if(color.equalsIgnoreCase(\"BLUE\"))&#123;\n         return new Blue();\n      &#125;\n      return null;\n   &#125;\n&#125;\n\n步骤7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。\npublic class FactoryProducer &#123;\n   public static AbstractFactory getFactory(String choice)&#123;\n      if(choice.equalsIgnoreCase(\"SHAPE\"))&#123;\n         return new ShapeFactory();\n      &#125; else if(choice.equalsIgnoreCase(\"COLOR\"))&#123;\n         return new ColorFactory();\n      &#125;\n      return null;\n   &#125;\n&#125;\n\n步骤 8 使用FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。\npublic class AbstractFactoryPatternDemo &#123;\n   public static void main(String[] args) &#123;\n \n      //获取形状工厂\n      AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\");\n \n      //获取形状为 Circle 的对象\n      Shape shape1 = shapeFactory.getShape(\"CIRCLE\");\n \n      //调用 Circle 的 draw 方法\n      shape1.draw();\n \n      //获取形状为 Rectangle 的对象\n      Shape shape2 = shapeFactory.getShape(\"RECTANGLE\");\n \n      //调用 Rectangle 的 draw 方法\n      shape2.draw();\n      \n      //获取形状为 Square 的对象\n      Shape shape3 = shapeFactory.getShape(\"SQUARE\");\n \n      //调用 Square 的 draw 方法\n      shape3.draw();\n \n      //获取颜色工厂\n      AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\");\n \n      //获取颜色为 Red 的对象\n      Color color1 = colorFactory.getColor(\"RED\");\n \n      //调用 Red 的 fill 方法\n      color1.fill();\n \n      //获取颜色为 Green 的对象\n      Color color2 = colorFactory.getColor(\"Green\");\n \n      //调用 Green 的 fill 方法\n      color2.fill();\n \n      //获取颜色为 Blue 的对象\n      Color color3 = colorFactory.getColor(\"BLUE\");\n \n      //调用 Blue 的 fill 方法\n      color3.fill();\n   &#125;\n&#125;\n\n步骤9 run\nInside Circle::draw() method.\nInside Rectangle::draw() method.\nInside Square::draw() method.\nInside Red::fill() method.\nInside Green::fill() method.\nInside Blue::fill() method.\n\n","slug":"设计模式","date":"2021-03-23T08:15:09.000Z","categories_index":"","tags_index":"To be God","author_index":"Phoenix"},{"id":"b1e76cb133a3f81cc5267f0d9f1ef90a","title":"灰度发布","content":"1.什么是灰度发布​        灰度发布是指A/B testing,即让一部分用户继续用产品特性a，一部分开始用产品特性b,如果用户对b没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到b上面。\n2.灰度发布流程![image-20210323154759087](/Users/kingboom/Library/Application Support/typora-user-images/image-20210323154759087.png)\n相关解释：\n​        选定策略：包括用户规模、发布频率、功能覆盖率、回滚策略、运营策略、新旧系统部署策略等；\n​        筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等\n​        部署系统：部署新系统、部署用户行为分析系统、设定分流规则、运营数据分析、分流规则微调\n​        发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表 \n3.Eureka实现灰度发布（优雅下线）\n直接停掉服务。\n​        默认情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。但这种做法的不好之处在于， 客户端已经停止了运行，但仍然在注册中心的列表中。 虽然通过一定的负载均衡策略或使用熔断器可以让服务正常进行，但有没有方法让注册中心马上知道服务已经下线呢？\n\n为了让注册中心马上知道服务要下线，可以向euraka注册中心发送delete请求\n    格式为/eureka/apps/&#123;application.name&#125;\n\n\n客户端主动通知注册中心下线\n​        如果你的eureka客户端是是一个spring boot应用，可以通过调用以下代码通知注册中心下线。 \nDiscoveryManager.getInstance().shutdownComponent();\n@RestController\npublic class HelloController &#123;\n    @Autowired\n    private DiscoveryClient client;\n \n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String index() &#123;\n        java.util.List&lt;ServiceInstance> instances = client.getInstances(\"hello-service\");       \n        return \"Hello World\";\n    &#125;\n    \n    @RequestMapping(value = \"/offline\", method = RequestMethod.GET)\n    public void offLine()&#123;\n    \tDiscoveryManager.getInstance().shutdownComponent();\n    &#125;   \n&#125;\n\n","slug":"灰度发布","date":"2021-03-23T07:13:43.000Z","categories_index":"categories","tags_index":"linux运维","author_index":"Phoenix"},{"id":"997fa7c1b5358f16e6c47f75508528f9","title":"数据库连接池（jdbc）","content":"今日内容1. 数据库连接池\n\n\n2. Spring JDBC : JDBC Template\n\n数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。\n        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。\n\n2. 好处：\n    1. 节约资源\n    2. 用户访问高效\n\n3. 实现：\n    1. 标准接口：DataSource   javax.sql包下的\n        1. 方法：\n            * 获取连接：getConnection()\n            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接\n\n    2. 一般我们不去实现它，有数据库厂商来实现\n        1. C3P0：数据库连接池技术\n        2. Druid：数据库连接池实现技术，由阿里巴巴提供的\n\n\n4. C3P0：数据库连接池技术\n    * 步骤：\n        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，\n            * 不要忘记导入数据库驱动jar包\n        2. 定义配置文件：\n            * 名称： c3p0.properties 或者 c3p0-config.xml\n            * 路径：直接将文件放在src目录下即可。\n\n        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource\n        4. 获取连接： getConnection\n    * 代码：\n         //1.创建数据库连接池对象\n        DataSource ds  = new ComboPooledDataSource();\n        //2. 获取连接对象\n        Connection conn = ds.getConnection();\n5. Druid：数据库连接池实现技术，由阿里巴巴提供的\n    1. 步骤：\n        1. 导入jar包 druid-1.0.9.jar\n        2. 定义配置文件：\n            * 是properties形式的\n            * 可以叫任意名称，可以放在任意目录下\n        3. 加载配置文件。Properties\n        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory\n        5. 获取连接：getConnection\n    * 代码：\n         //3.加载配置文件\n        Properties pro = new Properties();\n        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);\n        pro.load(is);\n        //4.获取连接池对象\n        DataSource ds = DruidDataSourceFactory.createDataSource(pro);\n        //5.获取连接\n        Connection conn = ds.getConnection();\n    2. 定义工具类\n        1. 定义一个类 JDBCUtils\n        2. 提供静态代码块加载配置文件，初始化连接池对象\n        3. 提供方法\n            1. 获取连接方法：通过数据库连接池获取连接\n            2. 释放资源\n            3. 获取连接池的方法\n\n\n    * 代码：\n        public class JDBCUtils &#123;\n\n            //1.定义成员变量 DataSource\n            private static DataSource ds ;\n        \n            static&#123;\n                try &#123;\n                    //1.加载配置文件\n                    Properties pro = new Properties();\n                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\n                    //2.获取DataSource\n                    ds = DruidDataSourceFactory.createDataSource(pro);\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        \n            /**\n             * 获取连接\n             */\n            public static Connection getConnection() throws SQLException &#123;\n                return ds.getConnection();\n            &#125;\n        \n            /**\n             * 释放资源\n             */\n            public static void close(Statement stmt,Connection conn)&#123;\n               /* if(stmt != null)&#123;\n                    try &#123;\n                        stmt.close();\n                    &#125; catch (SQLException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n        \n                if(conn != null)&#123;\n                    try &#123;\n                        conn.close();//归还连接\n                    &#125; catch (SQLException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;*/\n        \n               close(null,stmt,conn);\n            &#125;\n\n​​                public static void close(ResultSet rs , Statement stmt, Connection conn){\n​​                    if(rs != null){​                        try {​                            rs.close();​                        } catch (SQLException e) {​                            e.printStackTrace();​                        }​                    }\n​​                    if(stmt != null){​                        try {​                            stmt.close();​                        } catch (SQLException e) {​                            e.printStackTrace();​                        }​                    }​​                    if(conn != null){​                        try {​                            conn.close();//归还连接​                        } catch (SQLException e) {​                            e.printStackTrace();​                        }​                    }​                }​                /**                 * 获取连接池方法                 */\n            public static DataSource getDataSource()&#123;\n                return  ds;\n            &#125;\n        \n        &#125;\n\nSpring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发\n* 步骤：\n    1. 导入jar包\n    2. 创建JdbcTemplate对象。依赖于数据源DataSource\n        * JdbcTemplate template = new JdbcTemplate(ds);\n\n    3. 调用JdbcTemplate的方法来完成CRUD的操作\n        * update():执行DML语句。增、删、改语句\n        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合\n            * 注意：这个方法查询的结果集长度只能是1\n        * queryForList():查询结果将结果集封装为list集合\n            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中\n        * query():查询结果，将结果封装为JavaBean对象\n            * query的参数：RowMapper\n                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装\n                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)\n        * queryForObject：查询结果，将结果封装为对象\n            * 一般用于聚合函数的查询\n\n    4. 练习：\n        * 需求：\n            1. 修改1号数据的 salary 为 10000\n            2. 添加一条记录\n            3. 删除刚才添加的记录\n            4. 查询id为1的记录，将其封装为Map集合\n            5. 查询所有记录，将其封装为List\n            6. 查询所有记录，将其封装为Emp对象的List集合\n            7. 查询总记录数\n\n        * 代码：\n            \n            import cn.itcast.domain.Emp;\n            import cn.itcast.utils.JDBCUtils;\n            import org.junit.Test;\n            import org.springframework.jdbc.core.BeanPropertyRowMapper;\n            import org.springframework.jdbc.core.JdbcTemplate;\n            import org.springframework.jdbc.core.RowMapper;\n            \n            import java.sql.Date;\n            import java.sql.ResultSet;\n            import java.sql.SQLException;\n            import java.util.List;\n            import java.util.Map;\n            \n            public class JdbcTemplateDemo2 &#123;\n            \n                //Junit单元测试，可以让方法独立执行\n\n​​                    //1. 获取JDBCTemplate对象​                    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());​                    /**​                     * 1. 修改1号数据的 salary 为 10000​                     /​                    @Test​                    public void test1(){​​                        //2. 定义sql​                        String sql = “update emp set salary = 10000 where id = 1001”;​                        //3. 执行sql​                        int count = template.update(sql);​                        System.out.println(count);​                    }​                    /*                     * 2. 添加一条记录                     */                    @Test                    public void test2(){                        String sql = “insert into emp(id,ename,dept_id) values(?,?,?)”;                        int count = template.update(sql, 1015, “郭靖”, 10);                        System.out.println(count);\n                &#125;\n            \n                /**\n                 * 3.删除刚才添加的记录\n                 */\n                @Test\n                public void test3()&#123;\n                    String sql = &quot;delete from emp where id = ?&quot;;\n                    int count = template.update(sql, 1015);\n                    System.out.println(count);\n                &#125;\n            \n                /**\n                 * 4.查询id为1001的记录，将其封装为Map集合\n                 * 注意：这个方法查询的结果集长度只能是1\n                 */\n                @Test\n                public void test4()&#123;\n                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;\n                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);\n                    System.out.println(map);\n                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;\n            \n                &#125;\n            \n                /**\n                 * 5. 查询所有记录，将其封装为List\n                 */\n                @Test\n                public void test5()&#123;\n                    String sql = &quot;select * from emp&quot;;\n                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);\n            \n                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;\n                        System.out.println(stringObjectMap);\n                    &#125;\n                &#125;\n            \n                /**\n                 * 6. 查询所有记录，将其封装为Emp对象的List集合\n                 */\n            \n                @Test\n                public void test6()&#123;\n                    String sql = &quot;select * from emp&quot;;\n                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;\n            \n                        @Override\n                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;\n                            Emp emp = new Emp();\n                            int id = rs.getInt(&quot;id&quot;);\n                            String ename = rs.getString(&quot;ename&quot;);\n                            int job_id = rs.getInt(&quot;job_id&quot;);\n                            int mgr = rs.getInt(&quot;mgr&quot;);\n                            Date joindate = rs.getDate(&quot;joindate&quot;);\n                            double salary = rs.getDouble(&quot;salary&quot;);\n                            double bonus = rs.getDouble(&quot;bonus&quot;);\n                            int dept_id = rs.getInt(&quot;dept_id&quot;);\n            \n                            emp.setId(id);\n                            emp.setEname(ename);\n                            emp.setJob_id(job_id);\n                            emp.setMgr(mgr);\n                            emp.setJoindate(joindate);\n                            emp.setSalary(salary);\n                            emp.setBonus(bonus);\n                            emp.setDept_id(dept_id);\n            \n                            return emp;\n                        &#125;\n                    &#125;);\n\n​​                        for (Emp emp : list) {​                            System.out.println(emp);​                        }​                    }​​                    /**​                     * 6. 查询所有记录，将其封装为Emp对象的List集合​                     */​                    @Test                    public void test6_2(){                        String sql = “select * from emp”;                        List list = template.query(sql, new BeanPropertyRowMapper(Emp.class));                        for (Emp emp : list) {                            System.out.println(emp);                        }                    }\n                /**\n                 * 7. 查询总记录数\n                 */\n            \n                @Test\n                public void test7()&#123;\n                    String sql = &quot;select count(id) from emp&quot;;\n                    Long total = template.queryForObject(sql, Long.class);\n                    System.out.println(total);\n                &#125;\n            \n            &#125;\n\n","slug":"JDBC连接池&JDBCTemplate课堂笔记","date":"2021-03-23T04:00:16.000Z","categories_index":"","tags_index":"数据库","author_index":"Phoenix"},{"id":"1d53460b3441299b24ab126073336160","title":"数据库（mysql）","content":"今日内容\n数据库的基本概念\n\n\nMySQL数据库软件\n\n安装\n卸载\n配置\n\n\nSQL\n\n\n数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB\n2. 什么数据库？\n    * 用于存储和管理数据的仓库。\n\n3. 数据库的特点：\n    1. 持久化存储数据的。其实数据库就是一个文件系统\n    2. 方便存储和管理数据\n    3. 使用了统一的方式操作数据库 -- SQL\n\n​    4. 常见的数据库软件        * 参见《MySQL基础.pdf》\nMySQL数据库软件1. 安装\n    * 参见《MySQL基础.pdf》\n2. 卸载\n    1. 去mysql的安装目录找到my.ini文件\n        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n    2. 卸载MySQL\n    3. 删除C:/ProgramData目录下的MySQL文件夹。\n    \n3. 配置\n    * MySQL服务启动\n        1. 手动。\n        2. cmd--&gt; services.msc 打开服务的窗口\n        3. 使用管理员打开cmd\n            * net start mysql : 启动mysql的服务\n            * net stop mysql:关闭mysql服务\n    * MySQL登录\n        1. mysql -uroot -p密码\n        2. mysql -hip -uroot -p连接目标的密码\n        3. mysql --host=ip --user=root --password=连接目标的密码\n    * MySQL退出\n        1. exit\n        2. quit\n\n    * MySQL目录结构\n        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;\n            * 配置文件 my.ini\n        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n            * 几个概念\n                * 数据库：文件夹\n                * 表：文件\n                * 数据：数据\n\nSQL1.什么是SQL？\n    Structured Query Language：结构化查询语言\n    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\n    \n2.SQL通用语法\n    1. SQL 语句可以单行或多行书写，以分号结尾。\n    2. 可使用空格和缩进来增强语句的可读性。\n    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n    4. 3 种注释\n        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n        * 多行注释: /* 注释 */\n    \n3. SQL分类\n    1) DDL(Data Definition Language)数据定义语言\n        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n    2) DML(Data Manipulation Language)数据操作语言\n        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n    3) DQL(Data Query Language)数据查询语言\n        用来查询数据库中表的记录(数据)。关键字：select, where 等\n    4) DCL(Data Control Language)数据控制语言(了解)\n        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\n\nDDL:操作数据库、表1. 操作数据库：CRUD\n    1. C(Create):创建\n        * 创建数据库：\n            * create database 数据库名称;\n        * 创建数据库，判断不存在，再创建：\n            * create database if not exists 数据库名称;\n        * 创建数据库，并指定字符集\n            * create database 数据库名称 character set 字符集名;\n\n        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n            * create database if not exists db4 character set gbk;\n    2. R(Retrieve)：查询\n        * 查询所有数据库的名称:\n            * show databases;\n        * 查询某个数据库的字符集:查询某个数据库的创建语句\n            * show create database 数据库名称;\n    3. U(Update):修改\n        * 修改数据库的字符集\n            * alter database 数据库名称 character set 字符集名称;\n    4. D(Delete):删除\n        * 删除数据库\n            * drop database 数据库名称;\n        * 判断数据库存在，存在再删除\n            * drop database if exists 数据库名称;\n    5. 使用数据库\n        * 查询当前正在使用的数据库名称\n            * select database();\n        * 使用数据库\n            * use 数据库名称;\n\n\n2. 操作表\n    1. C(Create):创建\n        1. 语法：\n            create table 表名(\n                列名1 数据类型1,\n                列名2 数据类型2,\n                ....\n                列名n 数据类型n\n            );\n            * 注意：最后一列，不需要加逗号（,）\n            * 数据库类型：\n                1. int：整数类型\n                    * age int,\n                2. double:小数类型\n                    * score double(5,2)\n                3. date:日期，只包含年月日，yyyy-MM-dd\n                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss\n                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    \n                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\n                6. varchar：字符串\n                    * name varchar(20):姓名最大20个字符\n                    * zhangsan 8个字符  张三 2个字符\n\n\n        * 创建表\n            create table student(\n                id int,\n                name varchar(32),\n                age int ,\n                score double(4,1),\n                birthday date,\n                insert_time timestamp\n            );\n        * 复制表：\n            * create table 表名 like 被复制的表名;          \n    2. R(Retrieve)：查询\n        * 查询某个数据库中所有的表名称\n            * show tables;\n        * 查询表结构\n            * desc 表名;\n    3. U(Update):修改\n        1. 修改表名\n            alter table 表名 rename to 新的表名;\n        2. 修改表的字符集\n            alter table 表名 character set 字符集名称;\n        3. 添加一列\n            alter table 表名 add 列名 数据类型;\n        4. 修改列名称 类型\n            alter table 表名 change 列名 新列别 新数据类型;\n            alter table 表名 modify 列名 新数据类型;\n        5. 删除列\n            alter table 表名 drop 列名;\n    4. D(Delete):删除\n        * drop table 表名;\n        * drop table  if exists 表名 ;\n\n\n客户端图形化工具：SQLYog\n\nDML：增删改表中数据1. 添加数据：\n    * 语法：\n        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n    * 注意：\n        1. 列名和值要一一对应。\n        2. 如果表名后，不定义列名，则默认给所有列添加值\n            insert into 表名 values(值1,值2,...值n);\n        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n2. 删除数据：\n    * 语法：\n        * delete from 表名 [where 条件]\n    * 注意：\n        1. 如果不加条件，则删除表中所有记录。\n        2. 如果要删除所有记录\n            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n3. 修改数据：\n    * 语法：\n        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\n\n    * 注意：\n        1. 如果不加任何条件，则会将表中所有记录全部修改。\n\nDQL：查询表中的记录* select * from 表名;\n\n1. 语法：\n    select\n        字段列表\n    from\n        表名列表\n    where\n        条件列表\n    group by\n        分组字段\n    having\n        分组之后的条件\n    order by\n        排序\n    limit\n        分页限定\n\n\n2. 基础查询\n    1. 多个字段的查询\n        select 字段名1，字段名2... from 表名；\n        * 注意：\n            * 如果查询所有字段，则可以使用*来替代字段列表。\n    2. 去除重复：\n        * distinct\n    3. 计算列\n        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n            * 表达式1：哪个字段需要判断是否为null\n            * 如果该字段为null后的替换值。\n    4. 起别名：\n        * as：as也可以省略\n\n\n3. 条件查询\n    1. where子句后跟条件\n    2. 运算符\n        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;\n        * BETWEEN...AND  \n        * IN( 集合) \n        * LIKE：模糊查询\n            * 占位符：\n                * _:单个任意字符\n                * %：多个任意字符\n        * IS NULL  \n        * and  或 &amp;&amp;\n        * or  或 || \n        * not  或 !\n        \n            -- 查询年龄大于20岁\n\n            SELECT * FROM student WHERE age &gt; 20;\n            \n            SELECT * FROM student WHERE age &gt;= 20;\n            \n            -- 查询年龄等于20岁\n            SELECT * FROM student WHERE age = 20;\n            \n            -- 查询年龄不等于20岁\n            SELECT * FROM student WHERE age != 20;\n            SELECT * FROM student WHERE age &lt;&gt; 20;\n            \n            -- 查询年龄大于等于20 小于等于30\n            \n            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;\n            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;\n            SELECT * FROM student WHERE age BETWEEN 20 AND 30;\n            \n            -- 查询年龄22岁，18岁，25岁的信息\n            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n            SELECT * FROM student WHERE age IN (22,18,25);\n            \n            -- 查询英语成绩为null\n            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\n            \n            SELECT * FROM student WHERE english IS NULL;\n            \n            -- 查询英语成绩不为null\n            SELECT * FROM student WHERE english  IS NOT NULL;\n\n\n\n            -- 查询姓马的有哪些？ like\n            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n            -- 查询姓名第二个字是化的人\n            \n            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n            \n            -- 查询姓名是3个字的人\n            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;\n\n​                – 查询姓名中包含德的人                SELECT * FROM student WHERE NAME LIKE ‘%德%’;\n​    \n","slug":"MySQL基础课堂笔记","date":"2021-03-23T04:00:16.000Z","categories_index":"","tags_index":"数据库","author_index":"Phoenix"},{"id":"2f6fa7c456d90ea78f2273a18fcc64b4","title":"Spring Boot 总结","content":"1. Spring Boot概述目标：了解Spring Boot是什么，有什么作用\n小结：\nSpring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。\n2. Spring Boot入门目标：能够使用Spring Boot搭建项目\n分析：\n需求：可以在浏览器中访问http://localhost:8080/hello输出一串字符\n实现步骤：\n\n创建工程；\n添加依赖（启动器依赖，spring-boot-starter-web）；\n创建启动类；\n创建处理器Controller；\n测试\n\n小结：\nSpring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。\n\nspring-boot-starter-web默认的应用服务器端口是8080\n\n3. Java代码方式配置目标：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring\n分析：\n需求：使用Java代码配置数据库连接池，并可以在处理器中注入并使用\n步骤：\n\n添加依赖；\n创建数据库；\n创建数据库连接参数的配置文件jdbc.properties；\n创建配置类；\n改造处理器类注入数据源并使用\n\n小结：\npackage com.itheima.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@PropertySource(\"classpath:jdbc.properties\")\npublic class JdbcConfig &#123;\n\n    @Value(\"$&#123;jdbc.url&#125;\")\n    String url;\n    @Value(\"$&#123;jdbc.driverClassName&#125;\")\n    String driverClassName;\n    @Value(\"$&#123;jdbc.username&#125;\")\n    String username;\n    @Value(\"$&#123;jdbc.password&#125;\")\n    String password;\n\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setDriverClassName(driverClassName);\n        dataSource.setUrl(url);\n        dataSource.setUsername(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    &#125;\n\n&#125;\n\n\n\n\n4. Spring Boot属性注入方式目标：能够使用@ConfigurationProperties实现Spring Boot配置文件配置项读取和应用\n分析：\n需求：将配置文件中的配置项读取到一个对象中；\n实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。\n实现步骤：\n\n创建配置项类JdbcProperties类，在该类名上面添加@ConfigurationProperties；\n将jdbc.properties修改名称为application.properties；\n将JdbcProperties对象注入到JdbcConfig；\n测试\n\n小结：\n\n使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中\n\n@ConfigurationProperties(prefix = \"jdbc\")\npublic class JdbcProperties &#123;\n\n    private String url;\n    private String driverClassName;\n    private String username;\n    private String password;\n\n    public String getUrl() &#123;\n        return url;\n    &#125;\n\n    public void setUrl(String url) &#123;\n        this.url = url;\n    &#125;\n\n    public String getDriverClassName() &#123;\n        return driverClassName;\n    &#125;\n\n    public void setDriverClassName(String driverClassName) &#123;\n        this.driverClassName = driverClassName;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n&#125;\n\n\n\n\n\n使用@ConfigurationProperties在方法上面使用\n\n@Bean\n@ConfigurationProperties(prefix = \"jdbc\")\npublic DataSource dataSource() &#123;\n    return new DruidDataSource();\n&#125;\n\n\n\n5. 多个yml文件配置目标：可以将多个yml文件在application.yml文件中配置激活\n分析：\nyaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。\n1）yml配置文件的特征：\n\n树状层级结构展示配置项；\n配置项之间如果有关系的话需要分行空两格；\n配置项如果有值的话，那么需要在 :之后空一格再写配置项值；\n\n将application.properties配置文件修改为application.yml的话：\njdbc:\n  driverClassName: com.mysql.jdbc.Driver\n  url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;heima\n  username: root\n  password: root\n\nkey:\n  abc: cba\n  def:\n    - g\n    - h\n    - j\n\n\n\n2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。\n3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。\n小结：\n在多个配置文件时，需要将这些文件在application.yml文件中进行激活：\n#激活配置文件;需要指定其它的配置文件名称\nspring:\n  profiles:\n    active: abc,def\n\n\n\n6. 自动配置原理目标：了解Spring Boot项目的配置加载流程\n小结：\n\n在 META-INF\\spring.fatories文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件\n通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数\n\n\n7. lombok应用目标：使用lombok的注解实现pojo类的简化\n分析：\n使用Spring Boot整合SSM工程；需要使用到数据库数据。\n\n将数据库表数据导入到数据库中（springboot_test）；\n\n编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。\nlombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。\n\n在IDEA中安装lombok插件；\n添加lombok对应的依赖到项目pom.xml文件；\n改造实体类使用lombok注解\n\n\n\n小结：\n在Bean上使用：@Data ：自动提供getter和setter、hashCode、equals、toString等方法@Getter：自动提供getter方法@Setter：自动提供setter方法@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。\n8. Spring Boot整合-SpringMVC端口和静态资源目标：可以修改tomcat的端口和访问项目中的静态资源\n分析：\n\n修改tomcat端口\n查询**Properties，设置配置项（前缀+类变量名）到application配置文件中\n\n访问项目中的静态资源\n静态资源放置的位置；放置静态资源并访问这些资源\n\n\n小结：\n\n修改项目tomcat端口：\n\n#tomcat端口\nserver:\n  port: 80\n\n\n在spring boot项目中静态资源可以放置在如下目录：\n \n\n\n9.Spring Boot整合-SpringMVC拦截器目标：可以在Spring Boot项目中配置自定义SpringMVC拦截器\n分析：\n\n编写拦截器（实现HandlerInterceptor）；\n编写配置类实现 WebMvcConfigurer，在该类中添加各种组件；\n测试\n\n小结：\n可以在spring boot项目中通过配置类添加各种组件；如果要添加拦截器的话：\npackage com.itheima.config;\n\nimport com.itheima.interceptor.MyInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class MvcConfig implements WebMvcConfigurer &#123;\n\n    //注册拦截器\n    @Bean\n    public MyInterceptor myInterceptor()&#123;\n        return new MyInterceptor();\n    &#125;\n\n    //添加拦截器到spring mvc拦截器链\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(myInterceptor()).addPathPatterns(\"/*\");\n    &#125;\n&#125;\n\n\n\n\n10. Spring Boot整合-事务和连接池目标：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置\n分析：\n\n事务配置\n\n添加事务相关的启动器依赖，mysql相关依赖；\n编写业务类UserService使用事务注解@Transactional\n\n\n数据库连接池hikari配置\n只需要在application配置文件中指定数据库相关参数\n\n\n小结：\n\n事务配置；只需要添加jdbc启动器依赖\n数据库连接池使用默认的hikari，在配置文件中配置如下：\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;springboot_test\n    username: root\n    password: root\n\n\n\n\n11. Spring Boot整合-Mybatis目标：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项\n分析：\n\n添加启动器依赖；\n配置Mybatis：实体类别名包，日志，映射文件等；\n配置MapperScan\n\n小结：\n\n添加mybatis官方对于spring boot的一个启动器\n&lt;!--mybatis -->\n&lt;dependency>\n    &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n    &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.0.1&lt;/version>\n&lt;/dependency>\n  \n配置mybatis\nmybatis:\n  # 实体类别名包路径\n  type-aliases-package: com.itheima.pojo\n  # 映射文件路径\n  # mapper-locations: classpath:mappers&#x2F;*.xml\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n设置启动器类中的mapper扫描\n \n\n\n12. Spring Boot整合-通用Mapper目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper接口\n分析：\n通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。\n\n添加启动器依赖；\n改造UserMapper继承Mapper；\n修改启动引导类Application中的Mapper扫描注解；\n修改User实体类添加jpa注解；\n改造UserService实现业务功能；\n\n小结：\n\n在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解\n\n13. Spring Boot整合测试目标：可以访问处理器对应路径将数据库中的数据根据id查询\n分析：\n\n改造HelloController，注入UserService利用其方法实现查询；\n启动项目进行测试 http://localhost/user/用户id –&gt; http://localhost/user/8\n\n小结：\n修改了HelloController：\n@Autowired\nprivate UserService userService;\n\n/**\n * 根据用户id查询用户\n * @param id 用户id\n * @return 用户\n */\n@GetMapping(\"/user/&#123;id&#125;\")\npublic User queryById(@PathVariable Long id)&#123;\n    return userService.queryById(id);\n&#125;\n\n\n\n\n14. Spring Boot整合-Junit目标：在Spring Boot项目中使用Junit进行单元测试UserService的方法\n分析：\n\n添加启动器依赖spring-boot-starter-test；\n编写测试类\n\n小结：\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class UserServiceTest &#123;\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void queryById() &#123;\n        User user = userService.queryById(8L);\n        System.out.println(\"user = \" + user);\n    &#125;\n\n    @Test\n    public void saveUser() &#123;\n        User user = new User();\n        user.setUserName(\"test2\");\n        user.setName(\"test2\");\n        user.setAge(13);\n        user.setPassword(\"123456\");\n        user.setSex(1);\n        user.setCreated(new Date());\n        userService.saveUser(user);\n    &#125;\n&#125;\n\n\n在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest\n\n15. Spring Boot整合-redis目标：在Spring Boot项目中使用Junit测试RedisTemplate的使用\n分析：\n\n添加启动器依赖；spring-boot-starter-data-redis\n配置application.yml中修改redis的连接参数；（redis需要启动）\n编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）\n\n小结：\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class RedisTest &#123;\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Test\n    public void test()&#123;\n        //string 字符串\n        //redisTemplate.opsForValue().set(\"str\", \"heima\");\n        redisTemplate.boundValueOps(\"str\").set(\"heima\");\n        System.out.println(\"str = \" + redisTemplate.opsForValue().get(\"str\"));\n\n        //hash 散列\n        redisTemplate.boundHashOps(\"h_key\").put(\"name\", \"heima\");\n        redisTemplate.boundHashOps(\"h_key\").put(\"age\", 13);\n        //获取所有域\n        Set set = redisTemplate.boundHashOps(\"h_key\").keys();\n        System.out.println(\" hash散列的所有域：\" + set);\n        //获取所有值\n        List list = redisTemplate.boundHashOps(\"h_key\").values();\n        System.out.println(\" hash散列的所有域的值：\" + list);\n\n        //list 列表\n        redisTemplate.boundListOps(\"l_key\").leftPush(\"c\");\n        redisTemplate.boundListOps(\"l_key\").leftPush(\"b\");\n        redisTemplate.boundListOps(\"l_key\").leftPush(\"a\");\n        //获取全部元素\n        list = redisTemplate.boundListOps(\"l_key\").range(0, -1);\n        System.out.println(\" list列表中的所有元素：\" + list);\n\n        // set 集合\n        redisTemplate.boundSetOps(\"s_key\").add(\"a\", \"b\", \"c\");\n        set = redisTemplate.boundSetOps(\"s_key\").members();\n        System.out.println(\" set集合中的所有元素：\" + set);\n\n        // sorted set 有序集合\n        redisTemplate.boundZSetOps(\"z_key\").add(\"a\", 30);\n        redisTemplate.boundZSetOps(\"z_key\").add(\"b\", 20);\n        redisTemplate.boundZSetOps(\"z_key\").add(\"c\", 10);\n        set = redisTemplate.boundZSetOps(\"z_key\").range(0, -1);\n        System.out.println(\" zset有序集合中的所有元素：\" + set);\n    &#125;\n&#125;\n\n\n\n\n16. Spring Boot项目部署目标：将Spring Boot项目使用maven指令打成jar包并运行测试\n分析：\n\n需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的package；\n部署：java -jar 包名\n\n小结：\n\n添加打包组件\n&lt;build>\n    &lt;plugins>\n       &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 -->\n        &lt;plugin>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n        &lt;/plugin>\n    &lt;/plugins>\n&lt;/build>\n部署运行\njava -jar 包名\n\n","slug":"Spring Boot课堂笔记","date":"2021-03-23T04:00:16.000Z","categories_index":"","tags_index":"springboot","author_index":"Phoenix"},{"id":"752df47e81765b87f1a3577b1a4bb212","title":"新建md文件命令","content":"新建md‘$ hexo new “title”‘\n","slug":"新建md文件","date":"2021-03-23T04:00:16.000Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"ca61c2382a0ab3412965cfacf70e7f7f","title":"html&css","content":"HTML标签：表单标签* 表单：\n    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。\n    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围\n        * 属性：\n            * action：指定提交数据的URL\n            * method:指定提交方式\n                * 分类：一共7种，2种比较常用\n                   * get：\n                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。\n                        2. 请求参数大小是有限制的。\n                        3. 不太安全。\n                   * post：\n                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)\n                        2. 请求参数的大小没有限制。\n                        3. 较为安全。\n\n        * 表单项中的数据要想被提交：必须指定其name属性\n\n        * 表单项标签：\n        * input：可以通过type属性值，改变元素展示的样式\n            * type属性：\n                * text：文本输入框，默认值\n                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息    \n                * password：密码输入框\n                * radio:单选框\n                    * 注意：\n                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。\n                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值\n                        3. checked属性，可以指定默认值\n                * checkbox：复选框\n                    * 注意：\n                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值\n                        2. checked属性，可以指定默认值\n\n                * file：文件选择框\n                * hidden：隐藏域，用于提交一些信息。\n                * 按钮：\n                    * submit：提交按钮。可以提交表单\n                    * button：普通按钮\n                    * image：图片提交按钮\n                        * src属性指定图片的路径    \n\n           * label：指定输入项的文字描述信息\n               * 注意：\n                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。\n        * select: 下拉列表\n            * 子元素：option，指定列表项\n            \n        * textarea：文本域\n            * cols：指定列数，每一行有多少个字符\n            * rows：默认多少行。\n\nCSS：页面美化和布局控制1. 概念： Cascading Style Sheets 层叠样式表\n    * 层叠：多个样式可以作用在同一个html的元素上，同时生效\n\n2. 好处：\n    1. 功能强大\n    2. 将内容展示和样式控制分离\n        * 降低耦合度。解耦\n        * 让分工协作更容易\n        * 提高开发效率\n\n\n3. CSS的使用：CSS与html结合方式\n    1. 内联样式\n         * 在标签内使用style属性指定css代码\n         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;\n    2. 内部样式\n        * 在head标签内，定义style标签，style标签的标签体内容就是css代码\n        * 如：\n            &lt;style&gt;\n                div&#123;\n                    color:blue;\n                &#125;\n        \n            &lt;/style&gt;\n            &lt;div&gt;hello css&lt;/div&gt;\n    3. 外部样式\n        1. 定义css资源文件。\n        2. 在head标签内，定义link标签，引入外部的资源文件\n        * 如：\n            * a.css文件：\n                div&#123;\n                    color:green;\n                &#125;\n            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;\n            &lt;div&gt;hello css&lt;/div&gt;\n            &lt;div&gt;hello css&lt;/div&gt;\n\n    * 注意：\n        * 1,2,3种方式 css作用范围越来越大\n        * 1方式不常用，后期常用2,3\n        * 3种格式可以写为：\n            &lt;style&gt;\n                @import &quot;css/a.css&quot;;\n            &lt;/style&gt;\n\n4. css语法：\n    * 格式：\n        选择器 &#123;\n            属性名1:属性值1;\n            属性名2:属性值2;\n            ...\n        &#125;\n    * 选择器:筛选具有相似特征的元素\n    * 注意：\n        * 每一对属性需要使用；隔开，最后一对属性可以不加；\n\n\n5. 选择器：筛选具有相似特征的元素\n    * 分类：\n        1. 基础选择器\n            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一\n                * 语法：#id属性值&#123;&#125;\n            2. 元素选择器：选择具有相同标签名称的元素\n                * 语法： 标签名称&#123;&#125;\n                * 注意：id选择器优先级高于元素选择器\n            3. 类选择器：选择具有相同的class属性值的元素。\n                * 语法：.class属性值&#123;&#125;\n                * 注意：类选择器选择器优先级高于元素选择器\n        2. 扩展选择器：\n            1. 选择所有元素：\n                * 语法： *&#123;&#125;\n            2. 并集选择器：\n                * 选择器1,选择器2&#123;&#125;\n            \n            3. 子选择器：筛选选择器1元素下的选择器2元素\n                * 语法：  选择器1 选择器2&#123;&#125;\n            4. 父选择器：筛选选择器2的父元素选择器1\n                * 语法：  选择器1 &gt; 选择器2&#123;&#125;\n\n            5. 属性选择器：选择元素名称，属性名=属性值的元素\n                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;\n\n            6. 伪类选择器：选择一些元素具有的状态\n                * 语法： 元素:状态&#123;&#125;\n                * 如： &lt;a&gt;\n                    * 状态：\n                        * link：初始化的状态\n                        * visited：被访问过的状态\n                        * active：正在访问状态\n                        * hover：鼠标悬浮状态\n6. 属性\n    1. 字体、文本\n        * font-size：字体大小\n        * color：文本颜色\n        * text-align：对其方式\n        * line-height：行高 \n    2. 背景\n        * background：\n    3. 边框\n        * border：设置边框，符合属性\n    4. 尺寸\n        * width：宽度\n        * height：高度\n    5. 盒子模型：控制布局\n        * margin：外边距\n        * padding：内边距\n            * 默认情况下内边距会影响整个盒子的大小\n            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小\n\n        * float：浮动\n            * left\n            * right\n\n案例：&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>注册页面&lt;/title>\n&lt;style>\n    *&#123;\n        margin: 0px;\n        padding: 0px;\n        box-sizing: border-box;\n    &#125;\n    body&#123;\n        background: url(\"img/register_bg.png\") no-repeat center;\n        padding-top: 25px;\n    &#125;\n\n    .rg_layout&#123;\n        width: 900px;\n        height: 500px;\n        border: 8px solid #EEEEEE;\n        background-color: white;\n        /*让div水平居中*/\n        margin: auto;\n    &#125;\n\n    .rg_left&#123;\n        /*border: 1px solid red;*/\n        float: left;\n        margin: 15px;\n    &#125;\n    .rg_left > p:first-child&#123;\n        color:#FFD026;\n        font-size: 20px;\n    &#125;\n\n    .rg_left > p:last-child&#123;\n        color:#A6A6A6;\n        font-size: 20px;\n\n    &#125;\t\t\n\t    .rg_center&#123;\n\t        float: left;\n\t       /* border: 1px solid red;*/\n    &#125;\n\n    .rg_right&#123;\n        /*border: 1px solid red;*/\n        float: right;\n        margin: 15px;\n    &#125;\n\n    .rg_right > p:first-child&#123;\n        font-size: 15px;\n\n    &#125;\n    .rg_right p a &#123;\n        color:pink;\n    &#125;\n\n    .td_left&#123;\n        width: 100px;\n        text-align: right;\n        height: 45px;\n    &#125;\n    .td_right&#123;\n        padding-left: 50px ;\n    &#125;\n\n    #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;\n        width: 251px;\n        height: 32px;\n        border: 1px solid #A6A6A6 ;\n        /*设置边框圆角*/\n        border-radius: 5px;\n        padding-left: 10px;\n    &#125;\n    #checkcode&#123;\n        width: 110px;\n    &#125;\n\n    #img_check&#123;\n        height: 32px;\n        vertical-align: middle;\n    &#125;\n\n    #btn_sub&#123;\n        width: 150px;\n        height: 40px;\n        background-color: #FFD026;\n        border: 1px solid #FFD026 ;\n    &#125;\n\n&lt;/style>\n\n&lt;/head>\n&lt;body>\n\n&lt;div class=\"rg_layout\">\n    &lt;div class=\"rg_left\">\n        &lt;p>新用户注册&lt;/p>\n        &lt;p>USER REGISTER&lt;/p>\n\n    &lt;/div>\n\n    &lt;div class=\"rg_center\">\n        &lt;div class=\"rg_form\">\n            &lt;!--定义表单 form-->\n            &lt;form action=\"#\" method=\"post\">\n                &lt;table>\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"username\">用户名&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"password\">密码&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"email\">Email&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"name\">姓名&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"tel\">手机号&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label>性别&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">\n                            &lt;input type=\"radio\" name=\"gender\" value=\"male\"> 男\n                            &lt;input type=\"radio\" name=\"gender\" value=\"female\"> 女\n                        &lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"birthday\">出生日期&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\">&lt;/td>\n                    &lt;/tr>\n\n                    &lt;tr>\n                        &lt;td class=\"td_left\">&lt;label for=\"checkcode\" >验证码&lt;/label>&lt;/td>\n                        &lt;td class=\"td_right\">&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\">\n                            &lt;img id=\"img_check\" src=\"img/verify_code.jpg\">\n                        &lt;/td>\n                    &lt;/tr>\n\t                    &lt;tr>\n\t                        &lt;td colspan=\"2\" align=\"center\">&lt;input type=\"submit\" id=\"btn_sub\" value=\"注册\">&lt;/td>\n\t                    &lt;/tr>\n\t                &lt;/table>\n            &lt;/form>\n\t        &lt;/div>\n    &lt;/div>\n    &lt;div class=\"rg_right\">\n        &lt;p>已有账号?&lt;a href=\"#\">立即登录&lt;/a>&lt;/p>\n    &lt;/div>\n\t&lt;/div>\n\t&lt;/body>\n\t&lt;/html>\n","slug":"HTML&CSS课堂笔记","date":"2019-08-26T11:14:23.000Z","categories_index":"","tags_index":"前端","author_index":"Phoenix"},{"id":"b9dfd556530770a74514e4f3a5fd8a27","title":"javascript基础","content":"JavaScript：* 概念：\t一门客户端脚本语言\n\t* 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎\n\t* 脚本语言：不需要编译，直接就可以被浏览器解析执行了\n\n* 功能：\n\t* 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。\n\n* JavaScript发展史：\n\t1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--\t，后来更名为：ScriptEase\n\t2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript\n\t3. 1996年，微软抄袭JavaScript开发出JScript语言\n\t4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。\n\n\t* JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)\n\n* ECMAScript：客户端脚本语言的标准\n\t1. 基本语法：\n\t\t1. 与html结合方式\n\t\t\t1. 内部JS：\n\t\t\t\t* 定义&lt;script>，标签体内容就是js代码\n\t\t\t2. 外部JS：\n\t\t\t\t* 定义&lt;script>，通过src属性引入外部的js文件\n\n\t\t\t* 注意：\n\t\t\t\t1. &lt;script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。\n\t\t\t\t2. &lt;script>可以定义多个。\n\t\t2. 注释\n\t\t\t1. 单行注释：//注释内容\n\t\t\t2. 多行注释：/*注释内容*/\n\t\t3. 数据类型：\n\t\t\t1. 原始数据类型(基本数据类型)：\n\t\t\t\t1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)\n\t\t\t\t2. string：字符串。 字符串  \"abc\" \"a\" 'abc'\n\t\t\t\t3. boolean: true和false\n\t\t\t\t4. null：一个对象为空的占位符\n\t\t\t\t5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined\n\t\t\t\t\n\t\t\t2. 引用数据类型：对象\n\t\t\t\n\t\t4. 变量\n\t\t\t* 变量：一小块存储数据的内存空间\n\t\t\t* Java语言是强类型语言，而JavaScript是弱类型语言。\n\t\t\t\t* 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据\n\t\t\t\t* 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。\n\t\t\t* 语法：\n\t\t\t\t* var 变量名 = 初始化值;\n\t\t\t\n\t\t\t* typeof运算符：获取变量的类型。\n\t\t\t\t* 注：null运算后得到的是object\n\t\t5. 运算符\n\t\t\t1. 一元运算符：只有一个运算数的运算符\n\t\t\t\t++，-- ， +(正号)  \n\t\t\t\t* ++ --: 自增(自减)\n\t\t\t\t\t* ++(--) 在前，先自增(自减)，再运算\n\t\t\t\t\t* ++(--) 在后，先运算，再自增(自减)\n\t\t\t\t* +(-)：正负号\n\t\t\t    * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换\n                    * 其他类型转number：\n                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）\n                        * boolean转number：true转为1，false转为0\n\t\t\t2. 算数运算符\n\t\t\t\t+ - * / % ...\n\n\t\t\t3. 赋值运算符\n\t\t\t\t= += -+....\n\n\t\t\t4. 比较运算符\n\t\t\t\t> &lt; >= &lt;= == ===(全等于)\n\t\t\t\t* 比较方式\n                  1. 类型相同：直接比较\n                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。\n                  2. 类型不同：先进行类型转换，再比较\n                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\n\t\t\t5. 逻辑运算符\n\t\t\t\t&amp;&amp; || !\n\t\t\t\t* 其他类型转boolean：\n                   1. number：0或NaN为假，其他为真\n                   2. string：除了空字符串(\"\")，其他都是true\n                   3. null&amp;undefined:都是false\n                   4. 对象：所有对象都为true\n\t\t\t\n\t\t\t6. 三元运算符\n\t\t\t\t? : 表达式\n\t\t\t\tvar a = 3;\n\t\t        var b = 4;\n\t\t\n\t\t        var c = a > b ? 1:0;\n\t\t\t\t* 语法：\n\t\t\t\t\t* 表达式? 值1:值2;\n\t\t\t\t\t* 判断表达式的值，如果是true则取值1，如果是false则取值2；\n\t\t\t\n\t\t6. 流程控制语句：\n\t\t\t1. if...else...\n\t\t\t2. switch:\n\t\t\t\t* 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)\n\t\t\t\t\t* switch(变量):\n\t\t\t\t\t\tcase 值:\n\t\t\t\t* 在JS中,switch语句可以接受任意的原始数据类型\n\t\t\t3. while\n\t\t\t4. do...while\n\t\t\t5. for\n\t\t7. JS特殊语法：\n\t\t\t1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)\n\t\t\t2. 变量的定义使用var关键字，也可以不使用\n        \t\t* 用： 定义的变量是局部变量\n                * 不用：定义的变量是全局变量(不建议)\n\n\t\t8. 练习：99乘法表\n\t\t&lt;!DOCTYPE html>\n\t\t&lt;html lang=\"en\">\n\t\t&lt;head>\n\t\t    &lt;meta charset=\"UTF-8\">\n\t\t    &lt;title>99乘法表&lt;/title>\n\t\t    &lt;style>\n\t\t        td&#123;\n\t\t            border: 1px solid;\n\t\t        &#125;\n\t\t\n\t\t    &lt;/style>\n\t\t\n\t\t    &lt;script>\n\t\t\n\t\t        document.write(\"&lt;table  align='center'>\");\n\n\t\t        //1.完成基本的for循环嵌套，展示乘法表\n\t\t        for (var i = 1; i &lt;= 9 ; i++) &#123;\n\t\t            document.write(\"&lt;tr>\");\n\t\t            for (var j = 1; j &lt;=i ; j++) &#123;\n\t\t                document.write(\"&lt;td>\");\n\t\t\n\t\t                //输出  1 * 1 = 1\n\t\t                document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\");\n\t\t\n\t\t                document.write(\"&lt;/td>\");\n\t\t            &#125;\n\t\t            /*//输出换行\n\t\t            document.write(\"&lt;br>\");*/\n\t\t\n\t\t            document.write(\"&lt;/tr>\");\n\t\t        &#125;\n\t\t\n\t\t        //2.完成表格嵌套\n\t\t        document.write(\"&lt;/table>\");\n\t\t\n\t\t    &lt;/script>\n\t\t&lt;/head>\n\t\t&lt;body>\n\t\t\n\t\t&lt;/body>\n\t\t&lt;/html>\n\n\t2. 基本对象：\n\t\t1. Function：函数(方法)对象\n            1. 创建：\n                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧\n                2. \n                    function 方法名称(形式参数列表)&#123;\n                        方法体\n                    &#125;\n\n                3. \n                   var 方法名 = function(形式参数列表)&#123;\n                        方法体\n                   &#125;\n            2. 方法：\n\n            3. 属性：\n                length:代表形参的个数\n            4. 特点：\n                1. 方法定义是，形参的类型不用写,返回值类型也不写。\n                2. 方法是一个对象，如果定义名称相同的方法，会覆盖\n                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关\n                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数\n            5. 调用：\n                方法名称(实际参数列表);\n\t\t\n\t\t2. Array:数组对象\n            1. 创建：\n                1. var arr = new Array(元素列表);\n                2. var arr = new Array(默认长度);\n                3. var arr = [元素列表];\n            2. 方法\n                join(参数):将数组中的元素按照指定的分隔符拼接为字符串\n                push()\t向数组的末尾添加一个或更多元素，并返回新的长度。\n            3. 属性\n                length:数组的长度\n            4. 特点：\n                1. JS中，数组元素的类型可变的。\n                2. JS中，数组长度可变的。\n\t\t3. Boolean\n\t\t4. Date：日期对象\n            1. 创建：\n                var date = new Date();\n\n            2. 方法：\n                toLocaleString()：返回当前date对象对应的时间本地字符串格式\n                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差\n\t\t5. Math：数学对象\n            1. 创建：\n                * 特点：Math对象不用创建，直接使用。  Math.方法名();\n\n            2. 方法：\n                random():返回 0 ~ 1 之间的随机数。 含0不含1\n                ceil(x)：对数进行上舍入。\n                floor(x)：对数进行下舍入。\n                round(x)：把数四舍五入为最接近的整数。\n            3. 属性：\n                PI\n\t\t6. Number\n\t\t7. String\n\t\t8. RegExp：正则表达式对象\n\t\t\t1. 正则表达式：定义字符串的组成规则。\n\t\t\t\t1. 单个字符:[]\n\t\t\t\t\t如： [a] [ab] [a-zA-Z0-9_]\n\t\t\t\t\t* 特殊符号代表特殊含义的单个字符:\n\t\t\t\t\t\t\\d:单个数字字符 [0-9]\n\t\t\t\t\t\t\\w:单个单词字符[a-zA-Z0-9_]\n\t\t\t\t2. 量词符号：\n\t\t\t\t\t?：表示出现0次或1次\n\t\t\t\t\t*：表示出现0次或多次\n\t\t\t\t\t+：出现1次或多次\n\t\t\t\t\t&#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n\n\t\t\t\t\t\t* m如果缺省： &#123;,n&#125;:最多n次\n\t\t\t\t\t\t* n如果缺省：&#123;m,&#125; 最少m次\n\t\t\t\t3. 开始结束符号\n\t\t\t\t\t* ^:开始\n\t\t\t\t\t* $:结束\n\t\t\t2. 正则对象：\n\t\t\t\t1. 创建\n\t\t\t\t\t1. var reg = new RegExp(\"正则表达式\");\n\t\t\t\t\t2. var reg = /正则表达式/;\n\t\t\t\t2. 方法\t\n\t\t\t\t\t1. test(参数):验证指定的字符串是否符合正则定义的规范\t\n\t\t9. Global\n\t\t\t1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();\n\t\t\t2. 方法：\n\t\t\t    encodeURI():url编码\n\t\t\t    decodeURI():url解码\n\n\t\t\t    encodeURIComponent():url编码,编码的字符更多\n\t\t\t    decodeURIComponent():url解码\n\n\t\t\t    parseInt():将字符串转为数字\n\t\t\t        * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number\n\t\t\t    isNaN():判断一个值是否是NaN\n\t\t\t        * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false\n\n\t\t\t    eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。\n            3. URL编码\n               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\n\n* BOM\n\n* DOM\n\n\n\n\n\n​    \n","slug":"JavaScript基础笔记","date":"2019-08-26T07:13:43.000Z","categories_index":"","tags_index":"前端","author_index":"Phoenix"},{"id":"b60ec295ef5609360b5e4f746898908f","title":"Java高级","content":"标准类制作\n成员变量\n\n​    使用private修饰\n\n\n构造方法\n\n提供一个无参构造方法\n提供一个带多个参数的构造方法\n\n\n成员方法\n\n提供每一个成员变量对应的setXxx( )/getXxx( )\n提供一个显示对象信息的show（）\n\n\n创建对象并对其成员变量赋值的两种方式t\n\n无参构造方法创建对象后使用setXxx( )赋值\n使用带参构造方法直接创建带有属性值的对象    \n\n\n\n集合编程的时候如果要存储多个数据，使用长度固定的数组存储格式，不一定满足我们的需求，更适应不了变化的需求。所以集合应运而生！\n集合的接口们：Collection,List,Set,泛型，Map,Collections;\n集合：Collection–&gt; List–&gt;ArrayList,LinkedList…\n​                                    Set–&gt;HashSet,TreeSet…\n​                Map     –&gt;HashMap…\nCollection集合概述 \n​    是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素 \n​    JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现 \n创建Collection集合的对象 \n​    多态的方式 \n​    具体的实现类ArrayList\nCollection集合常用方法\n\n\n\n方法名\n说明\n\n\n\nboolean add(E e)\n添加元素\n\n\nboolean remove(Object o)\n从集合中移除指定的元素\n\n\nvoid clear()\n清空集合中的元素\n\n\nboolean contains(Object o)\n判断集合中是否存在指定的元素\n\n\nboolean isEmpty()\n判断集合是否为空\n\n\nint size()\n集合的长度，也就是集合中元素的个数\n\n\n集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变。\n泛型：可以改变存储的数据类型，使代码更加灵活\nArrayListpublic ArrayList();//创建一个空的集合对象\npublic boolean add(E e);//将指定的元素追加到此集合到末尾\npublic void add(int index,E element);//在此集合中的指定位置插入指定的元素\npublic boolean remove(int index);//删除指定索引处的元素，返回被删除的元素\npublic E remove(int index);//删除指定索引处的元素，返回被删除的元素\npublic E set(int index,E element);//修改指定索引处的元素，返回被修改的元素\npublic E get(int index);//返回指定索引处的元素\npublic int size();//返回集合中的元素的个数\n\n修饰符(权限修饰符/状态修饰符)private：同一类中 \n默认 ：同一包中\nprotected ：不同包的子类\npublic：公开\nfinal和static \nfinal 关键字是最终的意思，可以修饰成员方法，成员变量，类 \nfinal 修饰的特点\n修饰方法：表明该方法是最终方法，不能被重写 \n修饰变量：表明该变量是常量，不能再次被赋值 \n修饰类：表明该类是最终类，不能被继承\nstatic关键字表明被类的所有对象共享，可以通过类名调用\n多态（同一对象，在不同时刻表现出来的不同形态）举例：猫 \n我们可以说猫是猫：猫 cat = new 猫(); \n我们也可以说猫是动物：动物 animal = new 猫(); \n这里猫在不同的时刻表现出来了不同的形态，这就是多态\n多态的前提：有继承/实现关系 有方法重写 有父类引用指向子类对象\n多态中成员访问特点：\n成员变量：编译看左边，执行看左边 \n成员方法：编译看左边，执行看右边 \n为什么成员变量和成员方法的访问不一样呢？ 因为成员方法有重写，而成员变量没有\n多态的利弊：\n多态的好处：提高了程序的扩展性 具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作 多态的弊端：不能使用子类的特有功能\n多态的转型：\n\n向上转型 从子到父 父类引用指向子类对象 \n向下转型 从父到子 父类引用转为子类对象\n\n抽象类和接口在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类\n抽象类特点：\n抽象类和抽象方法必须使用 abstract 关键字修饰\n抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态\n抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类\n\n接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用 Java中的接口更多的体现在对行为的抽象\n接口特点：\n接口用关键字interface修饰 \n​    public interface 接口名 {}  \n类实现接口用implements表示 \n​    public class 类名 implements 接口名 {} \n接口不能实例化 \n接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 \n多态的形式：具体类多态，抽象类多态，接口多态。  \n多态的前提：有继承或者实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象 \n接口的子类 要么重写接口中的所有抽象方法 要么是抽象类\n\n抽象类和接口的区别：\n成员区别 \n​    抽象类     变量,常量；有构造方法；有抽象方法,也有非抽象方法 \n​    接口         常量；抽象方法 \n关系区别 \n​    类与类         继承，单继承 \n​    类与接口     实现，可以单实现，也可以多实现 \n​    接口与接口     继承，单继承，多继承 \n设计理念区别 \n​    抽象类     对类抽象，包括属性、行为 \n​    接口         对行为抽象，主要是行为\n/*案例*/\n//抽象类\n  public abstract class Door &#123;\n     public abstract void open();\n     public abstract void close();\n  &#125;\n//接口  \n  public interface Door &#123;\n     void open();\n     void close();\n  &#125;\n//例子\npublic interface Alram &#123;\n     void alarm();\n  &#125;\n  public abstract class Door &#123;\n     public abstract void open();\n     public abstract void close();\n  &#125;\n  public class AlarmDoor extends Door implements Alarm &#123;\n     public void oepn() &#123;\n        //....\n     &#125;\n     public void close() &#123;\n        //....\n     &#125;\n     public void alarm() &#123;\n        //....\n     &#125;\n  &#125;\n\n形参和返回值注意事项\n类名作为形参和返回值\n方法的形参是类名，其实需要的是该类的对象 \n方法的返回值是类名，其实返回的是该类的对象\n\n\n抽象类名作为形参和返回值\n方法的形参上抽象类名，其实需要的是该抽象类的子类对象\n方法的返回值是抽象类名，其实返回的是该抽象类的子类对象\n\n\n接口名作为形参和返回值\n方法的形参是接口名，其实需要的是该接口的实现类对象\n方法的返回值是接口名，其实返回的是该接口的实现类对象\n\n\n\nSome question内部类（就是在一个类中定义一个类。）public class Outer &#123;\npublic class Inner &#123;\n  \n      &#125; \t\n&#125;\n\n内部类的访问特点:内部类可以直接访问外部类的成员，包括私有;外部类要访问内部类的成员，必须创建对象\n内部类的分类：\n成员内部类；局部内部类；匿名内部类。\n在类的成员位置：成员内部类，外界创建对象使用成员内部类：\n//外部类名.内部类名 对象名 = 外部类对象.内部类对象;\nOuter.Inner oi = new Outer().new Inner();\n\n在类的局部位置：局部内部类 ;\n局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。\n匿名\n常用API (Math System Object Arrays 基本类型包装类 日期类)常用的工具类的设计思想：构造方法私有。成员都用static修饰。Math 类概述：Math 包含执行基本数字运算的方法 没有构造方法，如何使用类中的成员呢？ 看类的成员是否都是静态的，如果是，通过类名就可以直接调用\nMath类的常用方法：\n\n\n\n方法名\n说明\n\n\n\npublic static int abs(int a)\n返回参数的绝对值\n\n\npublic static double ceil(double a)\n返回大于或等于参数的最小double值，等于一个整数\n\n\npublic static double floor(double a)\n返回小于或等于参数的最大double值，等于一个整数\n\n\npublic static int round(float a)\n按照四舍五入返回最接近参数的int\n\n\npublic static int max(int a,int b)\n返回两个int值中的较大值\n\n\npublic static int min(int a,int b)\n返回两个int值中的较小值\n\n\npublic static double pow(double a,double b)\n返回a的b次幂的值\n\n\npublic static double random()\n返回值为double的正值，[0.0,1.0)\n\n\nSystem类概述：System包含几个有用的类字段和方法，它不能被实例化\n\n\n\n方法名\n说明\n\n\n\npublic static void exit（int status）\n终止当前运行的Java虚拟机，非零表示异常终止\n\n\npublic static long currentTimeMillis()\n返回当前时间（以毫秒为单位）\n\n\nObject 类的概述：Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类。\n\n\n\n方法名\n说明\n\n\n\npublic String toString()\n返回对象的字符串表示形式。建议所有子类重写该方法，自动生成\n\n\npublic boolean equals(Object obj)\n比较对象是否相等。默认比较地址，重写可以比较内容，自动生成\n\n\nArrays类概述：Arrays类包含用于操作数组的各种方法\n\n\n\n方法名\n说明\n\n\n\npublic static String toString(int[] a)\n返回指定数组的内容的字符串表示形式\n\n\npublic static void sort(int[] a)\n按照数字顺序排列指定的数组\n\n\n基本类型包装类概述：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 \n常用的操作之一：用于基本数据类型与字符串之间的转换。\n\n\n\n基本数据类型\n包装类\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nchar\nCharacter\n\n\nboolean\nBoolean\n\n\n自动装箱和拆箱\n装箱：把基本数据类型转换为对应的包装类类型 \n拆箱：把包装类类型转换为对应的基本数据类型\nInteger i = 100;  // 自动装箱\ni += 200;         // i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱\n\n注意：在使用包装类类型的时候，如果做操作，最好先判断是否为 null          \n我们推荐的是，只要是对象，在使用前就必须进行不为 null 的判断\n日期类（Date）Date 代表了一个特定的时间，精确到毫秒\n\n\n\n方法名\n说明\n\n\n\npublic Date()\n分配一个Date对象，并初始化，以便它代表它被分配到时间，精确到毫秒\n\n\npublic Date(long date)\n分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n\n\npublic long getTime()\n获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n\n\npublic void setTime(long time)\n设置时间，给的是毫秒值\n\n\nSimpleDateFormat 类概述（具体类，用于以区域设置敏感的方式格式化和解析日期）\n\n\n方法名\n说明\n\n\n\npublic SimpleDateFormat()\n构造一个SimpleDateFormat，使用默认模式和日期格式\n\n\npublic SimpleDateFormat(String pattern)\n构造一个SimpleDateFormat使用给定的模式和默认的日期格式\n\n\nCalendar类概述（Calendar 为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法）Calendar 提供了一个类方法 getInstance 用于获取 Calendar 对象，其日历字段已使用当前日期和时间初始化：Calendar rightNow = Calendar.getInstance();\n\n\n\n方法名\n说明\n\n\n\npublic int get(int field)\n返回给定日历字段的值\n\n\npublic abstract void add(int field, int amount)\n根据日历的规则，将指定的时间量添加或减去给定的日历字段\n\n\npublic final void set(int year,int month,int date)\n设置当前日历的年月日\n\n\n异常Throwable异常体系：Throwable–&gt;Error &amp; Exception–&gt;RuntimeException&amp;非RuntimeException\nError：严重问题，不需要处理 \nException：称为异常类，它表示程序本身可以处理的问题 \nRuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码  \n非 RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了\n如果程序出现问题，我们没有做任何异常处理，最终jvm会把异常的名称，异常原因及出现位置信息输出在控制台，然后程序停止执行\n抛出异常两种方案：try…catch…  &amp;  throws 异常类名；\nThtowable的成员方法\n\n\n\n方法名\n说明\n\n\n\npublic String getMessage()\n返回此 throwable 的详细消息字符串\n\n\npublic String toString()\n返回此可抛出的简短描述\n\n\npublic void printStackTrace()\n把异常的错误信息输出在控制台\n\n\n自定义异常当Java内置的异常都不能明确的说明异常情况的时候，需要创建自己的异常\n需要注意的是，唯一有用的就是类型名这个信息，所以我们不需要在异常类的设计上花费太多精力\n一个类要想成为异常类的一员，要么继承Exception，要么继承RuntimeException\n通常情况下，会直接继承自Exception类，给出无参和带参构造方法即可\n\n\n\npublic class 异常类名 extends Exception &#123;\n\t//无参构造\n\t//带参构造\n&#125;\n//demo\npublic class ScoreException extends Exception &#123;\n\tpublic ScoreException() &#123;&#125;\n\tpublic ScoreException(String message) &#123;\n\t     super(message);\n\t&#125;\n&#125; \n\nthrows 和 throw 的区别throws \n\n用在方法声明后面，跟的是异常类名 \n\n表示抛出异常，由该方法的调用者来处理 \n\n表示出现异常的一种可能性，并不一定会发生这些异常\n\n\nthrow \n\n用在方法体内，跟的是异常对象名 \n\n表示抛出异常，由方法体内的语句处理 \n\n执行 throw 一定抛出了某种异常\n\n\nIO流处理File类（用于操作文件和目录）File：它说文件和目录路径名的抽象表示\n\n文件和目录说可以通过file封装成对象的\n\n对于file而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。 \n\n将来是通过具体的操作把这个路径的内容转换成具体存在\n\n\n\n方法名\n说明\n\n\n\nFile(String pathname)\n通过将给定的路径名字符串转换成抽象路径名来创建新的File实例\n\n\nFile(String parent, String child)\n从父路径名字符串和子路径名字符串创建新的 File实例\n\n\nFile(File parent, String child)\n从父抽象路径名和子路径名字符串创建新的 File实例\n\n\n\n\nFile类增删功能\n\n\n方法名\n说明\n\n\n\npublic boolean createNewFile()\n当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件\n\n\npublic boolean mkdir()\n创建由此抽象路径名命名的目录\n\n\npublic boolean mkdirs()\n创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录\n\n\n\n\n\n方法名\n说明\n\n\n\npublic boolean delete()\n删除由此抽象路径名表示的文件或目录\n\n\n绝对路径和相对路径的区别\n​    l绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\\itcast\\java.txt\n​    l相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\\java.txt\n删除目录时的注意事项：\n​    l如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录\nFile类判断和获取功能\n\n\n方法名\n说明\n\n\n\npublic boolean isDirectory()\n测试此抽象路径名表示的File是否为目录\n\n\npublic boolean isFile()\n测试此抽象路径名表示的File是否为文件\n\n\npublic boolean exists()\n测试此抽象路径名表示的File是否存在\n\n\npublic String getAbsolutePath()\n返回此抽象路径名的绝对路径名字符串\n\n\npublic String getPath()\n将此抽象路径名转换为路径名字符串\n\n\npublic String getName()\n返回由此抽象路径名表示的文件或目录的名称\n\n\npublic String[] list()\n返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n\n\npublic File[] listFiles()\n返回此抽象路径名表示的目录中的文件和目录的File对象数组\n\n\n字节流和字符流（操作文件传输）IO流概述：\n\nIO：输入/输出(Input/Output)\n\n流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输\n\nIO流就是用来处理设备间数据传输问题的\n​    常见的应用：文件复制；文件上传；文件下载\n\nIO流分类：\n\n按照数据的流向\n\n输入流：读数据\n输出流：写数据\n\n\n\n按照数据类型来分\n\n字节流\n 字节输入流；字节输出流\n字符流\n 字符输入流；字符输出流\n\n\n\n\n一般来说，我们说IO流的分类是按照数据类型来分的\n\n如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流，\n否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流\n\n\n内存划分（伊甸园区，旧生代区，永久区）内存的优良划分是系统优化很关键的一环，主要考察内存优化和GC机制\nRuntime类：\npublic class MemoryT &#123;\n    public static void main(String[] args) &#123;\n        Runtime run=Runtime.getRuntime();//取得Runtime对象\n//        Runtime rund = new Runtime();//这个不行，因为Runtime类采用单例设计模式 它的构造方法Runtime()是私有的；\n        System.out.println(\"内存1\"+run.maxMemory());\n        \n        System.out.println(\"内存3\"+run.totalMemory());//返回值都为long类型 就是一子节 1byte；\n      \n     \t  System.out.println(\"内存2\"+run.freeMemory());\n    &#125;\n&#125;\n\n伊甸园区：新生的对象都存在这里，但不是所有对象都永久存在，伴随着内存的不足会进行gc处理空出空间给新生的对象；\n旧生代区：长期使用的对象存在这里，当伊甸园区进行了gc处理仍然空间不足时，该区进行gc处理；\n永久区：永不清理的内存空间；\n调整内存大小：xms-初始内存大小  默认为物理内存1/64但小于1g；\n​                           xmx-最大内存大小 默认为物理内存的1/4但小于1g ；\n​                           xmn-伊甸园区堆内存大小； 因为默认值实在太小了，我们实际服务器基本就16g以上，所以需要手动调整优化性能；\n加载器class dmp&#123;&#125;\npublic class LoaderT &#123;\n    class demo&#123;&#125;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Class&lt;?> cls = Class.forName(\"dmp\");\n        System.out.println(cls.getClassLoader());//AppClassLoade sun.misc.Launcher$AppClassLoader@18b4aac2\n        System.out.println(cls.getClassLoader().getParent());//ExtClassLoade\n        System.out.println(cls.getClassLoader().getParent().getParent());//三层加载器\n    &#125;\n&#125;\n\n类加载器可自定义，Java中采用双亲加载方式，加载系统类时调用另一套加载器。\n","slug":"Java高级","date":"2018-12-03T02:03:26.000Z","categories_index":"","tags_index":"Java","author_index":"Phoenix"},{"id":"bb75e9d1c3429d83254e84314ef5ffe1","title":"java基础","content":"Java概述Java的跨平台性实现原理：通过jvm（Java virtual machine）作翻译。\njre和jdk：\njre是Java的运行环境，包括jvm和运行时所需要的核心类库。如果是运行一个已有Java程序，则只需要安装jre即可。\njdk是Java程序开发工具包，包含jre和开发人员使用的工具。其中的开发工具包含编译工具（Javac.exe）和运行工具（Java.exe)。我们需要开发一个全新的Java程序，那么必须安装jdk。\nJava的hello world开发Java程序，需要三个步骤：编写程序-编译程序-运行程序\n​                                  文件变化：Java源程序-通过编译器Javac.exe- Java字节码文件- 运行程序Java.exe\npublic class HelloWorld()&#123;\n\t\t\tpublic static void main(String[] args)&#123;\n\t\t\t\t\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t\t&#125;\n&#125;\n\n基本语法注释：不谈\n关键字：被java语言赋予特定含义的单词，也是命名时需要规避的单词，关键字的字母全部为小写。\n常量：在程序运行过程中，其值不可发生改变的量。\n基本数据类型：整数；浮点型；字符；布尔；\n变量：在程序运行过程中，其值可发生变化的量从本质上讲，变量是内存中一小块区域。\n标识符：就是给类，方法，变量等起名字的符号。命名规范：小驼峰：firstName（方法、变量）大驼峰：firstName（类）\n类型转换：\n自动类型转换：把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量 double a = 10;\n强制类型转换：把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量 int k = (int)88.88;\n运算符算术运算符：+ - * / %（加减乘除余）字符的“+”操作：拿字符在计算机底层对应的数值来进行计算 A+a=162;\n算术表达式中包含多个基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。提升到表达式中最高等级操作数相同的类型\n提升等级顺序：byte,short,char –&gt; int –&gt;long –&gt; float –&gt; double\n当“+”操作中出现字符串，“+”被判定为字符串连接符，而不是算术运算，而当多个数字和字符串同时出现，则从左到右依次判定。1+99+“hello”+28+22+“world”=“200hello2822world”\n赋值运算符：=，+=，-=，*=，/=，%=（赋值，加后赋值，减后赋值，乘后赋值，除后赋值，取余后赋值）拓展的赋值运算符隐含了强制类型转换\nint a=1;\nint b=2;\na=b;//a=2\na+=b;//a=4\na-=b;//a=2\na*=b;//a=4\na/=b;//a=2\na%=b;//a=0\n\n自增自减运算符：++，–（自增，自减）注意事项：\n\n++和– 既可以放在变量的后边，也可以放在变量的前边。\n单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。\n参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者–。       参与操作的时候，如果放在变量的前边，先拿变量做++或者–，后拿变量参与操作。\n\n关系运算符：==，！=，&gt;，&gt;=，&lt;，&lt;=int a=1;\nint b=2l;\nboolean c=true;\nc=a==b;//c=false\nc=a!=b;//c=true\nc=a>b;//c=false\nc=a>=b;//c=false\nc=a&lt;=b;//c=true\nc=a&lt;b;//c=true\n\n逻辑运算符 &amp;，|，^，！，&amp;&amp;，｜｜（与，或，异或，非，短路与，短路或）3&lt;x&lt;6\nx&gt;3和x&lt;6\nx&gt;3&amp;&amp;x&lt;6\n逻辑运算符，是用来连接关系表达式的运算符。 当然，逻辑运算符也可以直接连接布尔类型的常量或者变量。\n\u0003\nint a=1;\nint b=2;\nboolean c=true;\nc=a&amp;b;//c=true a&amp;b，a和b都是true，结果为true，否则为false\nc=a|b;//c=true a|b，a和b都是false，结果为false，否则为true\nc=a^b;//c=true a^b，a和b结果不同为true，相同为false\nc=!b;//c=true !a，结果和a的结果正好相反\nc=a&amp;&amp;b;//c=true 作用和&amp;相同，但是有短路效果\nc=a||b;//c=true 作用和|相同，但是有短路效果\n\n注意事项：\n逻辑与&amp;，无论左边真假，右边都要执行。       短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。\n逻辑或|，无论左边真假，右边都要执行。       短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。\n最常用的逻辑运算符：&amp;&amp;，||，!\n\n三元运算符格式：关系表达式？表达式1:表达式2；\n范式：a&gt;b?a:b;\n计算规则：\n​            首先计算关系表达式的值\n​            如果值为true，表达式1的值就是运算结果\n​            如果值为false，表达式2的值就是运算结果\nint a = 1;\nint b = 2; \nint c = 3;\nc = a > b ? a:b;// c = b;\n\n三元案例：动物园有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断力两只老虎的体重是否相同。\nint weight1 = 180;\nint weight2 = 200;\n(weight1 == weight2)?true : false;\n\n数据输入（Scanner）import java.util.Scanner;//导包的动作必须出现在类定义的上边\n\nScanner sc = new Scanner(System.in);//上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变。\nint i = sc.nextInt();//上面这个格式里面，只有i是变量名，可以变，其他的都不允许变。\n\n流程控制（循环(for, while,do…while)，顺序，分支（if,switch））需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。\n分析：\n\n键盘录入月份数据，使用变量接收\nimport java.util.Scanner;\u000b\nScanner sc = new Scanner(System.in);\u000b\nint month = sc.nextInt();\n\n多情况判断，采用switch语句实现\nswitch (month) {\u000b    \ncase X:\u000b    \ncase X:\u000b    \ncase X:\u000b    \ndefault:\u000b}\n\n在每种情况中，完成输出对应的季节（选择了几个）\ncase 3:\u000b    \n​    System.out.println(“春季”);\u000b    \n​    break; \ncase 6:\u000b    \n​    System.out.println(“夏季”);\n\u000b    break; \ncase 9:\u000b \n   System.out.println(“秋季”);\u000b\n​    break;\ncase 12:\u000b\n​    System.out.println(“冬季”);\u000b\n​    break;\n\n\n注意事项：在switch语句中，如果case控制的语句体后面不写break，将出现穿透现象，在不判断下一个case值的情况下，向下运行，直到遇到break，或者整体switch语句结束\n数组（array）数组(array)是一种用于存储多个相同类型数据的存储模型\n数组的定义格式：\n\n格式一：数据类型[ ] 变量名\n范式： int [ ] arr;\n定义了一个int类型的变量，变量名上arr数组\n\n\n格式二：数据类型 变量名[ ]\n范式：int arr[ ]\n定义了一个int类型的变量，变量名是arr数组\n\n数组初始化方式：\n数组动态初始化：初始化时只指定数组长度，由系统为数组分配初始值\n\n格式：数据类型 [ ] 变量名 = new 数据类型 [ ];\n范式：int [ ] arr = new int[3]; \n\n数组元素访问：数组名[索引]\n内存分配：Java程序在运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。\n栈内存：存储局部变量 定义在方法中的变量，例如：arr 使用完毕，立即消失 \n堆内存：存储new出来的内容(实体，对象) 数组在初始化时，会为存储空间添加默认值 整数：0 浮点数：0.0 布尔：false 字符：空字符 引用数据类型：null 每一个new出来的东西都有一个地址值 使用完毕，会在垃圾回收器空闲时被回收\n数组静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度\n\n格式： 数据类型 [] 变量名 = new 数据类型[ ]{数据1，数据2，数据3，……};\n范例：int [ ] arr = new int [ ]{1,2,3};\n简化格式：数据类型 [ ] 变量名 = {数据1，数据2，数据3，……};\n范例：int [ ] arr = {1,2,3};\n\n/*例子 获取最大值 152 150 163 171 128 130 81 168*/\nint [] arr = &#123;152,150,163,171,128,130,81,168&#125;;\nint max;\nint max = arr[0];\nfor(i=0;i&lt;arr.length;i++)&#123;\n  if(arr[i]>max)&#123;\n    max=arr[i];\n  &#125;\n&#125;\nsout arr[i];\n\n方法方法重载：方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\n\n多个方法在同一个类中\n多个方法具有相同的方法名\n多个方法的参数不相同，类型不同或者数量不同\n\nDebug（调试）","slug":"java基础","date":"2018-09-21T07:10:50.000Z","categories_index":"","tags_index":"java","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    注册页面\n\n    *{\n        margin: 0px;\n        padding: 0px;\n        box-sizing: border-box;\n    }\n    body{\n        background: url(\"img/register_bg.png\") no-repeat center;\n        padding-top: 25px;\n    }\n\n    .rg_layout{\n        width: 900px;\n        height: 500px;\n        border: 8px solid #EEEEEE;\n        background-color: white;\n        /*让div水平居中*/\n        margin: auto;\n    }\n\n    .rg_left{\n        /*border: 1px solid red;*/\n        float: left;\n        margin: 15px;\n    }\n    .rg_left > p:first-child{\n        color:#FFD026;\n        font-size: 20px;\n    }\n\n    .rg_left > p:last-child{\n        color:#A6A6A6;\n        font-size: 20px;\n\n    }\n\n\n    .rg_center{\n        float: left;\n       /* border: 1px solid red;*/\n\n    }\n\n    .rg_right{\n        /*border: 1px solid red;*/\n        float: right;\n        margin: 15px;\n    }\n\n    .rg_right > p:first-child{\n        font-size: 15px;\n\n    }\n    .rg_right p a {\n        color:pink;\n    }\n\n    .td_left{\n        width: 100px;\n        text-align: right;\n        height: 45px;\n    }\n    .td_right{\n        padding-left: 50px ;\n    }\n\n    #username,#password,#email,#name,#tel,#birthday,#checkcode{\n        width: 251px;\n        height: 32px;\n        border: 1px solid #A6A6A6 ;\n        /*设置边框圆角*/\n        border-radius: 5px;\n        padding-left: 10px;\n    }\n    #checkcode{\n        width: 110px;\n    }\n\n    #img_check{\n        height: 32px;\n        vertical-align: middle;\n    }\n\n    #btn_sub{\n        width: 150px;\n        height: 40px;\n        background-color: #FFD026;\n        border: 1px solid #FFD026 ;\n    }\n\n\n\n\n\n\n\n    \n        新用户注册\n        USER REGISTER\n\n    \n\n    \n        \n            \n            \n                \n                    \n                        用户名\n                        \n                    \n\n                    \n                        密码\n                        \n                    \n\n                    \n                        Email\n                        \n                    \n\n                    \n                        姓名\n                        \n                    \n\n                    \n                        手机号\n                        \n                    \n\n                    \n                        性别\n                        \n                             男\n                             女\n                        \n                    \n\n                    \n                        出生日期\n                        \n                    \n\n                    \n                        验证码\n                        \n                            \n                        \n                    \n\n\n                    \n                        \n                    \n                \n\n            \n\n\n        \n\n    \n\n    \n        已有账号?立即登录\n    \n\n\n\n\n\n\n","slug":"day08_html&css/11_案例-注册页面(css)","date":"2018-05-15T09:32:25.205Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    css属性\n\n\n    \n        div{\n            border: 1px solid red;\n            width: 100px;\n        }\n        .div1{\n            width: 100px;\n            height: 100px;\n            /*外边距*/\n           /* margin: 50px; */\n        }\n        .div2{\n            width: 200px;\n            height: 200px;\n            padding: 50px;\n            /*\n                设置盒子的属性，让width和height就是最终盒子的大小\n             */\n            box-sizing: border-box;\n        }\n\n        .div3{\n            float: left;\n        }\n\n        .div4{\n            float: left;\n        }\n\n        .div5{\n            float: right;\n        }\n\n    \n\n\n\n\n    \n            \n\n    \n\n    aaaa\n    bbbbb\n    cccc\n\n","slug":"day08_html&css/10_CSS属性_盒子模型","date":"2018-05-15T07:28:48.647Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    css属性\n\n\n    \n        p{\n            color: #FF0000;\n            font-size: 30px;\n            text-align: center;\n            line-height: 200px;\n            /*\n                border 边框\n             */\n            border: 1px solid red;\n\n        }\n        div{\n            border: 1px solid red;\n            /*\n                尺寸\n             */\n            height: 200px;\n            width: 200px;\n            /*\n                背景\n             */\n            background: url(\"img/logo.jpg\") no-repeat center;\n        }\n    \n\n\n\n\n    传智播客\n    \n        黑马程序员\n\n    \n\n","slug":"day08_html&css/9_CSS属性","date":"2018-05-15T07:09:41.526Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    扩展选择器\n\n    \n        div p{\n            color:red;\n        }\n\n        div > p {\n            border: 1px solid;\n        }\n\n        input[type='text']{\n            border: 5px solid;\n        }\n\n        a:link{\n            color: pink;\n        }\n\n        a:hover{\n            color: green;\n        }\n\n        a:active{\n            color: yellow;\n        }\n\n        a:visited{\n            color: red;\n        }\n\n    \n\n\n\n    \n        传智播客\n    \n    黑马程序员\n\naaa\n\n    \n    \n\n\n            \n\n    黑马程序员\n\n\n\n\n\n","slug":"day08_html&css/8_扩展选择器","date":"2018-05-15T06:40:56.220Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    基础选择器\n\n    \n\n\n\n        .cls1{\n\n            color: blue;\n        }\n\n        div{\n            color:green;\n        }\n\n\n        #div1{\n               color: red;\n           }\n\n    \n\n\n\n\n    传智播客\n    黑马程序员\n\n    传智学院\n\n\n","slug":"day08_html&css/7_基础选择器","date":"2018-05-15T04:26:22.945Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"div{\n    color:green;\n}\n\np{\n    color: red;\n    font-size: 30px\n}","slug":"day08_html&css/css/a","date":"2018-05-15T04:09:11.960Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    Title\n   -->\n\n    \n        @import \"css/a.css\";\n    \n\n\n\n\nhello css\nhello css\n\n呵呵\n\n\n","slug":"day08_html&css/6_css与html结合方式3","date":"2018-05-15T04:08:22.309Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    Title\n    \n        div{\n            color:blue;\n        }\n\n    \n\n\n\n\nhello css\nhello css\n\n\n","slug":"day08_html&css/5_css与html结合方式2","date":"2018-05-15T03:58:56.642Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    Title\n\n\n\n\nhello css\n\n\n\n","slug":"day08_html&css/4_css与html结合方式1","date":"2018-05-15T03:55:30.154Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    注册页面\n\n\n\n    \n    \n        \n            \n                用户名\n                \n            \n\n            \n                密码\n                \n            \n\n            \n                Email\n                \n            \n\n            \n                姓名\n                \n            \n\n            \n                手机号\n                \n            \n\n            \n                性别\n                 男\n                     女\n                \n            \n\n            \n                出生日期\n                \n            \n\n            \n                验证码\n                \n                    \n                \n            \n\n\n            \n                \n            \n        \n\n\n    \n\n\n","slug":"day08_html&css/3_案例1_注册页面(html)","date":"2018-05-15T02:23:22.635Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    表单标签\n\n\n\n    \n\n\n\n     用户名 ：\n    密码：\n    性别：  男\n           女\n            \n    爱好： 逛街\n         Java\n         游戏\n\n    图片：\n    隐藏域： \n\n    取色器：\n    生日： \n    生日： \n    邮箱： \n    年龄： \n\n    省份：\n            --请选择--\n            北京\n            上海\n            陕西\n         \n\n    自我描述：\n        \n\n    \n    \n    \n    \n\n\n\n\n\n","slug":"day08_html&css/2_表单标签_表单项标签","date":"2018-05-15T02:09:48.090Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    表单标签\n\n\n\n    \n\n\n\n    用户名：\n    密码：\n\n    \n\n\n\n","slug":"day08_html&css/1_表单标签","date":"2018-05-15T01:25:23.907Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    黑马旅游网\n\n\n\n    \n    \n    \n       \n        \n            \n                \n            \n        \n\n        \n        \n            \n                \n                    \n                        \n                            \n                        \n                        \n                            \n                        \n                        \n                            \n                        \n                    \n                \n\n            \n        \n\n        \n        \n            \n                \n                    \n                        \n                            首页\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n\n                        \n                            门票\n                        \n                    \n                \n            \n        \n\n        \n        \n            \n                \n            \n        \n\n        \n        \n            \n                \n                黑马精选\n                \n            \n        \n\n        \n        \n            \n                \n                    \n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 899\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 899\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 899\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 899\n                        \n                    \n                \n            \n        \n\n        \n        \n            \n                \n                国内游\n                \n            \n        \n\n        \n        \n            \n                \n                    \n                        \n                            \n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n                    \n\n                    \n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n\n                    \n                \n            \n        \n\n        \n        \n            \n                \n                境外游\n                \n            \n        \n\n        \n        \n            \n                \n                    \n                        \n                            \n                        \n\n                        \n\n                            \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                           \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                           \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n                    \n\n                    \n                        \n\n                           \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                           \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n                        \n\n                           \n                            上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)\n                            &yen; 699\n                        \n\n\n                    \n                \n            \n        \n        \n        \n            \n                \n            \n        \n\n        \n        \n            \n                \n                江苏传智播客教育科技股份有限公司\n                版权所有Copyright 2006-2018&copy;, All Rights Reserved 苏ICP备16007882\n                \n            \n        \n        \n    \n\n\n\n","slug":"day07_html/9_综合案例_网站首页","date":"2018-05-14T02:00:34.511Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    表格标签\n\n\n\n    \n        \n           编号\n            姓名\n            成绩-->\n            编号\n            姓名\n            成绩\n\n        \n\n        \n            1\n            小龙女\n            100\n\n        \n\n        \n            2\n            杨过\n            50\n\n        \n\n    \n\n\n    \n\n\n    \n\n        \n            学生信息表\n\n            \n                编号\n                 姓名\n                 成绩-->\n                编号\n                姓名\n                成绩\n\n            \n        \n\n\n\n        \n            \n                1\n                小龙女\n                100\n\n            \n\n            \n                2\n                杨过\n                50\n\n            \n\n        \n\n        \n            \n                3\n                尹志平\n                10\n\n            \n\n        \n\n\n    \n\n    \n\n    \n        \n\n            编号\n            姓名\n            成绩\n\n        \n\n        \n\n            小龙女\n            100\n\n        \n\n        \n            2\n            杨过\n\n\n        \n\n    \n\n\n    \n\n\n\n\n\n","slug":"day07_html/8_表格标签","date":"2018-05-13T04:11:54.033Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    黑马程序员简介\n\n\n\n    \n    \n        公司简介\n    \n\n    \n\n\n\n\n\n\"中关村黑马程序员训练营\"是由传智播客联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。\n\n\n\n目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。\n\n\n\n\n黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。\n中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。\n\n\n\n\n一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。\n\n\n\n\n\n    \n    \n        \n            江苏传智播客教育科技股份有限公司\n            版权所有Copyright 2006-2018&copy;, All Rights Reserved 苏ICP备16007882\n        \n    \n    \n\n\n\n","slug":"day07_html/3_案例1_公司简介","date":"2018-05-13T03:31:21.434Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    块标签\n\n\n    \n\n    黑马程序员\n    传智播客\n\n    \n    黑马程序员\n    传智播客\n\n\n\n","slug":"day07_html/7_块标签","date":"2018-05-13T03:24:04.183Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    连接标签\n\n\n\n    \n\n    点我\n    \n\n    点我\n    \n    点我\n\n    \n\n    列表标签\n    联系我们\n\n    \n    \n\n\n\n","slug":"day07_html/6_连接标签","date":"2018-05-13T03:17:13.070Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    列表标签\n\n\n\n    \n    早上起床干的事情\n    \n        睁眼\n         看手机\n         穿衣服\n         洗漱\n    \n   \n\n    早上起床干的事情\n    \n        睁眼\n         看手机\n         穿衣服\n         洗漱\n    \n\n\n    早上起床干的事情\n    \n        睁眼\n         看手机\n         穿衣服\n         洗漱\n    \n\n    早上起床干的事情\n    \n        睁眼\n         看手机\n         穿衣服\n         洗漱\n    \n\n\n\n","slug":"day07_html/5_列表标签","date":"2018-05-13T03:02:26.832Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    图片标签\n\n\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n","slug":"day07_html/html/4_图片标签","date":"2018-05-13T02:53:39.078Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    图片标签\n\n\n\n\n    \n\n    \n\n    \n\n    \n\n\n","slug":"day07_html/4_图片标签","date":"2018-05-13T02:51:58.335Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    文本标签\n\n\n    \n    \n    白日依山尽，--> \n    黄河入海流。\n\n   \n\n    黑马旅游网 \n    黑马旅游网\n    黑马旅游网\n    黑马旅游网\n    黑马旅游网\n    黑马旅游网\n    黑马旅游网\n\n    \n    \n    1 黑马旅游网黑马旅游网黑马旅游网马旅游网黑马旅游网马旅游网黑马旅游网马旅游网黑马旅游网马旅游网黑马旅游网马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网。\n    \n    \n    2 黑马旅游网黑马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网。\n    \n\n    \n    3 黑马旅游网黑马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网 黑马旅游网黑马旅游网黑马旅游网黑马旅游网。\n    \n\n   \n    \n    \n   \n    白日依山尽\n    白日依山尽\n    \n    \n    白日依山尽\n    白日依山尽\n    \n    \n    白日依山尽 \n\n    黑马程序员 \n\n    \n\n\n    \n        白日依山尽 \n    \n        \n\n\n\n","slug":"day07_html/2_文本标签","date":"2018-05-13T02:27:52.984Z","categories_index":"","tags_index":"","author_index":"Phoenix"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n\n\n    \n    呵呵\n\n\n呵呵\n\n","slug":"day07_html/1_HelloWorld","date":"2018-05-13T01:41:44.126Z","categories_index":"","tags_index":"","author_index":"Phoenix"}]