
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爱意随风起 || Java高级</title>
    <meta name="author" content="phenix-fledgling">
    <meta name="description" content="phenix ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">爱意随风起</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a href="">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>爱意随风起</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a href="">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java高级 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2018/12/3
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/java" style=color:#879cff>
                    java
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h1><ol>
<li><p>成员变量</p>
<ul>
<li>​    使用private修饰</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>提供一个无参构造方法</li>
<li>提供一个带多个参数的构造方法</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li>提供每一个成员变量对应的setXxx( )/getXxx( )</li>
<li>提供一个显示对象信息的show（）</li>
</ul>
</li>
<li><p>创建对象并对其成员变量赋值的两种方式t</p>
<ul>
<li>无参构造方法创建对象后使用setXxx( )赋值</li>
<li>使用带参构造方法直接创建带有属性值的对象    </li>
</ul>
</li>
</ol>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>编程的时候如果要存储多个数据，使用<strong>长度固定的数组存储格式，不一定满足我们的需求</strong>，更适应不了变化的需求。所以集合应运而生！</p>
<p><strong>集合的接口们：</strong>Collection,List,Set,泛型，Map,Collections;</p>
<p>集合：<strong>Collection</strong>–&gt; <strong>List</strong>–&gt;ArrayList,LinkedList…</p>
<p>​                                    <strong>Set</strong>–&gt;HashSet,TreeSet…</p>
<p>​                <strong>Map</strong>     –&gt;HashMap…</p>
<p><strong>Collection集合概述</strong> </p>
<p>​    是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素 </p>
<p>​    JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现 </p>
<p><strong>创建Collection集合的对象</strong> </p>
<p>​    多态的方式 </p>
<p>​    具体的实现类ArrayList</p>
<p>Collection集合常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>添加元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中移除指定的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合中的元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody></table>
<p><strong>集合类的特点</strong>：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变。</p>
<p><strong>泛型：可以改变存储的数据类型，使代码更加灵活</strong></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>;<span class="comment">//创建一个空的集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;<span class="comment">//将指定的元素追加到此集合到末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="comment">//在此集合中的指定位置插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="comment">//修改指定索引处的元素，返回被修改的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//返回指定索引处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//返回集合中的元素的个数</span></span><br></pre></td></tr></table></figure>

<h1 id="修饰符-权限修饰符-状态修饰符"><a href="#修饰符-权限修饰符-状态修饰符" class="headerlink" title="修饰符(权限修饰符/状态修饰符)"></a>修饰符(权限修饰符/状态修饰符)</h1><p>private：同一类中 </p>
<p>默认 ：同一包中</p>
<p>protected ：不同包的子类</p>
<p>public：公开</p>
<p>final和static </p>
<p>final 关键字是最终的意思，可以修饰成员方法，成员变量，类 </p>
<p>final 修饰的特点</p>
<p>修饰方法：表明该方法是最终方法，不能被重写 </p>
<p>修饰变量：表明该变量是常量，不能再次被赋值 </p>
<p>修饰类：表明该类是最终类，不能被继承</p>
<p>static关键字表明<strong>被类的所有对象共享</strong>，<strong>可以通过类名调用</strong></p>
<h1 id="多态（同一对象，在不同时刻表现出来的不同形态）"><a href="#多态（同一对象，在不同时刻表现出来的不同形态）" class="headerlink" title="多态（同一对象，在不同时刻表现出来的不同形态）"></a>多态（同一对象，在不同时刻表现出来的不同形态）</h1><p>举例：猫 </p>
<p>我们可以说猫是猫：猫 cat = new 猫(); </p>
<p>我们也可以说猫是动物：动物 animal = new 猫(); </p>
<p>这里猫在不同的时刻表现出来了不同的形态，这就是多态</p>
<p><strong>多态的前提：有继承/实现关系 有方法重写 有父类引用指向子类对象</strong></p>
<p><strong>多态中成员访问特点</strong>：</p>
<p><u>成员变量：编译看左边，执行看左边</u> </p>
<p><u>成员方法：编译看左边，执行看右边</u> </p>
<p>为什么成员变量和成员方法的访问不一样呢？ 因为成员方法有重写，而成员变量没有</p>
<p><strong>多态的利弊：</strong></p>
<p>多态的好处：提高了程序的扩展性 具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作 多态的弊端：不能使用子类的特有功能</p>
<p><strong>多态的转型：</strong></p>
<ul>
<li>向上转型 从子到父 父类引用指向子类对象 </li>
<li>向下转型 从父到子 父类引用转为子类对象</li>
</ul>
<h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><p>在Java中，<strong>一个没有方法体的方法应该定义为抽象方法</strong>，<strong>而类中如果有抽象方法，该类必须定义为抽象类</strong></p>
<p><strong>抽象类特点：</strong></p>
<p><strong><u>抽象类和抽象方法必须使用</u> <u>abstract</u> <u>关键字修饰</u></strong></p>
<p><strong><u>抽象类中不一定有抽象方法</u>，<u>有抽象方法的类一定是抽象类</u></strong></p>
<p><strong>抽象类不能实例化 抽象类如何实例化呢？<u>参照多态的方式，通过子类对象实例化，这叫抽象类多态</u></strong></p>
<p><strong>抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类</strong></p>
<hr>
<p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用 Java中的接口更多的体现在对行为的抽象</p>
<p><strong>接口特点：</strong></p>
<p>接口用关键字interface修饰 </p>
<p>​    public interface 接口名 {}  </p>
<p>类实现接口用implements表示 </p>
<p>​    public class 类名 implements 接口名 {} </p>
<p>接口不能实例化 </p>
<p>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 </p>
<p>多态的形式：具体类多态，抽象类多态，接口多态。  </p>
<p>多态的前提：有继承或者实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象 </p>
<p><strong><u>接口的子类 要么重写接口中的所有抽象方法 要么是抽象类</u></strong></p>
<hr>
<p><strong>抽象类和接口的区别：</strong></p>
<p><strong>成员区别</strong> </p>
<p>​    抽象类     变量,常量；有构造方法；有抽象方法,也有非抽象方法 </p>
<p>​    接口         常量；抽象方法 </p>
<p><strong>关系区别</strong> </p>
<p>​    类与类         继承，单继承 </p>
<p>​    类与接口     实现，可以单实现，也可以多实现 </p>
<p>​    接口与接口     继承，单继承，多继承 </p>
<p><strong>设计理念区别</strong> </p>
<p>​    抽象类     对类抽象，包括属性、行为 </p>
<p>​    接口         对行为抽象，主要是行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*案例*/</span></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//接口  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="形参和返回值注意事项"><a href="#形参和返回值注意事项" class="headerlink" title="形参和返回值注意事项"></a>形参和返回值注意事项</h1><ul>
<li>类名作为形参和返回值<ul>
<li>方法的形参是类名，其实需要的是该类的对象 </li>
<li>方法的返回值是类名，其实返回的是该类的对象</li>
</ul>
</li>
<li>抽象类名作为形参和返回值<ul>
<li>方法的形参上抽象类名，其实需要的是该抽象类的子类对象</li>
<li>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</li>
</ul>
</li>
<li>接口名作为形参和返回值<ul>
<li>方法的形参是接口名，其实需要的是该接口的实现类对象</li>
<li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li>
</ul>
</li>
</ul>
<h1 id="Some-question内部类（就是在一个类中定义一个类。）"><a href="#Some-question内部类（就是在一个类中定义一个类。）" class="headerlink" title="Some question内部类（就是在一个类中定义一个类。）"></a>Some question内部类（就是在一个类中定义一个类。）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部类的访问特点</strong>:内部类可以直接访问外部类的成员，包括私有;外部类要访问内部类的成员，必须创建对象</p>
<p><strong>内部类的分类：</strong></p>
<p><strong>成员内部类；局部内部类；匿名内部类。</strong></p>
<p>在类的成员位置：成员内部类，外界创建对象使用成员内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span></span><br><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在类的局部位置：局部内部类 ;</p>
<p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p>
<p>匿名</p>
<h1 id="常用API-Math-System-Object-Arrays-基本类型包装类-日期类-常用的工具类的设计思想：构造方法私有。成员都用static修饰。"><a href="#常用API-Math-System-Object-Arrays-基本类型包装类-日期类-常用的工具类的设计思想：构造方法私有。成员都用static修饰。" class="headerlink" title="常用API (Math System Object Arrays 基本类型包装类 日期类)常用的工具类的设计思想：构造方法私有。成员都用static修饰。"></a>常用API (Math System Object Arrays 基本类型包装类 日期类)常用的工具类的设计思想：构造方法私有。成员都用static修饰。</h1><h2 id="Math-类概述："><a href="#Math-类概述：" class="headerlink" title="Math 类概述："></a><strong>Math 类概述</strong>：</h2><p>Math 包含执行基本数字运算的方法 没有构造方法，如何使用类中的成员呢？ 看类的成员是否都是静态的，如果是，通过类名就可以直接调用</p>
<p>Math类的常用方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public static int abs(int a)</td>
<td align="left">返回参数的绝对值</td>
</tr>
<tr>
<td align="left">public static double ceil(double a)</td>
<td align="left">返回大于或等于参数的最小double值，等于一个整数</td>
</tr>
<tr>
<td align="left">public static double floor(double a)</td>
<td align="left">返回小于或等于参数的最大double值，等于一个整数</td>
</tr>
<tr>
<td align="left"><strong>public static int round(float a)</strong></td>
<td align="left">按照四舍五入返回最接近参数的int</td>
</tr>
<tr>
<td align="left"><strong>public static int max(int a,int b)</strong></td>
<td align="left">返回两个int值中的较大值</td>
</tr>
<tr>
<td align="left">public static int min(int a,int b)</td>
<td align="left">返回两个int值中的较小值</td>
</tr>
<tr>
<td align="left">public static double pow(double a,double b)</td>
<td align="left">返回a的b次幂的值</td>
</tr>
<tr>
<td align="left">public static double random()</td>
<td align="left">返回值为double的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
<h2 id="System类概述："><a href="#System类概述：" class="headerlink" title="System类概述："></a><strong>System类概述：</strong></h2><p>System包含几个有用的类字段和方法，它不能被实例化</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit（int status）</td>
<td>终止当前运行的Java虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td><strong>public static long currentTimeMillis()</strong></td>
<td><strong>返回当前时间（以毫秒为单位）</strong></td>
</tr>
</tbody></table>
<h2 id="Object-类的概述："><a href="#Object-类的概述：" class="headerlink" title="Object 类的概述："></a><strong>Object 类的概述：</strong></h2><p>Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式。建议所有子类重写该方法，自动生成</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较对象是否相等。默认比较地址，重写可以比较内容，自动生成</td>
</tr>
</tbody></table>
<h2 id="Arrays类概述："><a href="#Arrays类概述：" class="headerlink" title="Arrays类概述："></a><strong>Arrays类概述：</strong></h2><p>Arrays类包含用于操作数组的各种方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>public static String toString(int[] a)</strong></td>
<td>返回指定数组的内容的字符串表示形式</td>
</tr>
<tr>
<td><strong>public static void sort(int[] a)</strong></td>
<td>按照数字顺序排列指定的数组</td>
</tr>
</tbody></table>
<p><strong>基本类型包装类概述：</strong>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 </p>
<p>常用的操作之一：用于基本数据类型与字符串之间的转换。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p><strong>自动装箱和拆箱</strong></p>
<p>装箱：把基本数据类型转换为对应的包装类类型 </p>
<p>拆箱：把包装类类型转换为对应的基本数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line">i += <span class="number">200</span>;         <span class="comment">// i = i + 200;  i + 200 自动拆箱；i = i + 200; 是自动装箱</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在使用包装类类型的时候，如果做操作，最好先判断是否为 null          </p>
<p>我们推荐的是，只要是对象，在使用前就必须进行不为 null 的判断</p>
<h2 id="日期类（Date）"><a href="#日期类（Date）" class="headerlink" title="日期类（Date）"></a>日期类（Date）</h2><p>Date 代表了一个特定的时间，精确到毫秒</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>分配一个Date对象，并初始化，以便它代表它被分配到时间，精确到毫秒</td>
</tr>
<tr>
<td>public Date(long date)</td>
<td>分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数</td>
</tr>
<tr>
<td><strong>public long getTime()</strong></td>
<td>获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值</td>
</tr>
<tr>
<td><strong>public void setTime(long time)</strong></td>
<td>设置时间，给的是毫秒值</td>
</tr>
</tbody></table>
<h3 id="SimpleDateFormat-类概述（具体类，用于以区域设置敏感的方式格式化和解析日期）"><a href="#SimpleDateFormat-类概述（具体类，用于以区域设置敏感的方式格式化和解析日期）" class="headerlink" title="SimpleDateFormat 类概述（具体类，用于以区域设置敏感的方式格式化和解析日期）"></a>SimpleDateFormat 类概述（具体类，用于以区域设置敏感的方式格式化和解析日期）</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat，使用默认模式和日期格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat使用给定的模式和默认的日期格式</td>
</tr>
</tbody></table>
<h3 id="Calendar类概述（Calendar-为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法）"><a href="#Calendar类概述（Calendar-为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法）" class="headerlink" title="Calendar类概述（Calendar 为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法）"></a>Calendar类概述（Calendar 为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法）</h3><p>Calendar 提供了一个类方法 getInstance 用于获取 Calendar 对象，其日历字段已使用当前日期和时间初始化：Calendar rightNow = Calendar.getInstance();</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>返回给定日历字段的值</td>
</tr>
<tr>
<td>public abstract void add(int field, int amount)</td>
<td>根据日历的规则，将指定的时间量添加或减去给定的日历字段</td>
</tr>
<tr>
<td>public final void set(int year,int month,int date)</td>
<td>设置当前日历的年月日</td>
</tr>
</tbody></table>
<h1 id="异常Throwable"><a href="#异常Throwable" class="headerlink" title="异常Throwable"></a>异常Throwable</h1><p>异常体系：Throwable–&gt;Error &amp; Exception–&gt;RuntimeException&amp;非RuntimeException</p>
<p>Error：严重问题，不需要处理 </p>
<p>Exception：称为异常类，它表示程序本身可以处理的问题 </p>
<p>RuntimeException：在编译期是不检查的，出现问题后，需要我们回来修改代码  </p>
<p>非 RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能正常运行了</p>
<p><strong>如果程序出现问题，我们没有做任何异常处理，最终jvm会把异常的名称，异常原因及出现位置信息输出在控制台，然后程序停止执行</strong></p>
<p>抛出异常两种方案：try…catch…  &amp;  throws 异常类名；</p>
<p>Thtowable的成员方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getMessage()</td>
<td>返回此 throwable 的详细消息字符串</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出在控制台</td>
</tr>
</tbody></table>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当Java内置的异常都不能明确的说明异常情况的时候，需要创建自己的异常</span><br><span class="line">需要注意的是，唯一有用的就是类型名这个信息，所以我们不需要在异常类的设计上花费太多精力</span><br><span class="line">一个类要想成为异常类的一员，要么继承Exception，要么继承RuntimeException</span><br><span class="line">通常情况下，会直接继承自Exception类，给出无参和带参构造方法即可</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 异常类名 <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">	<span class="comment">//无参构造</span></span><br><span class="line">	<span class="comment">//带参构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ScoreException</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ScoreException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	     <span class="keyword">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="throws-和-throw-的区别"><a href="#throws-和-throw-的区别" class="headerlink" title="throws 和 throw 的区别"></a>throws 和 throw 的区别</h2><p>throws </p>
<ul>
<li><p>用在方法声明后面，跟的是异常类名 </p>
</li>
<li><p>表示抛出异常，由该方法的调用者来处理 </p>
</li>
<li><p>表示出现异常的一种可能性，并不一定会发生这些异常</p>
</li>
</ul>
<p>throw </p>
<ul>
<li><p>用在方法体内，跟的是异常对象名 </p>
</li>
<li><p>表示抛出异常，由方法体内的语句处理 </p>
</li>
<li><p>执行 throw 一定抛出了某种异常</p>
</li>
</ul>
<h1 id="IO流处理"><a href="#IO流处理" class="headerlink" title="IO流处理"></a>IO流处理</h1><h2 id="File类（用于操作文件和目录）"><a href="#File类（用于操作文件和目录）" class="headerlink" title="File类（用于操作文件和目录）"></a>File类（用于操作文件和目录）</h2><p>File：它说文件和目录路径名的抽象表示</p>
<ul>
<li><p>文件和目录说可以通过file封装成对象的</p>
</li>
<li><p>对于file而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。 </p>
</li>
<li><p>将来是通过具体的操作把这个路径的内容转换成具体存在</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>通过将给定的路径名字符串转换成抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建新的 File实例</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>从父抽象路径名和子路径名字符串创建新的 File实例</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="File类增删功能"><a href="#File类增删功能" class="headerlink" title="File类增删功能"></a>File类增删功能</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>创建由此抽象路径名命名的目录</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody></table>
<p><strong>绝对路径和相对路径的区别</strong></p>
<p>​    l绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\itcast\java.txt</p>
<p>​    l相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\java.txt</p>
<p><strong>删除目录时的注意事项：</strong></p>
<p>​    l如果一个目录中有内容(目录，文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录</p>
<h2 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory()</td>
<td>测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回由此抽象路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
</tbody></table>
<h1 id="字节流和字符流（操作文件传输）"><a href="#字节流和字符流（操作文件传输）" class="headerlink" title="字节流和字符流（操作文件传输）"></a>字节流和字符流（操作文件传输）</h1><p>IO流概述：</p>
<ul>
<li><p>IO：输入/输出(Input/Output)</p>
</li>
<li><p>流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输</p>
</li>
<li><p>IO流就是用来处理设备间数据传输问题的</p>
<p>​    常见的应用：文件复制；文件上传；文件下载</p>
</li>
<li><p>IO流分类：</p>
<ul>
<li><p>按照数据的流向</p>
<ul>
<li><p>输入流：读数据</p>
<p>输出流：写数据</p>
</li>
</ul>
</li>
<li><p>按照数据类型来分</p>
<ul>
<li><p>字节流</p>
<p> 字节输入流；字节输出流</p>
<p>字符流</p>
<p> 字符输入流；字符输出流</p>
</li>
</ul>
</li>
</ul>
<p>一般来说，我们说IO流的分类是按照<strong>数据类型</strong>来分的</p>
</li>
<li><p>如果数据通过Window自带的记事本软件打开，我们还可以<strong>读懂里面的内容</strong>，就使用<strong>字符流</strong>，</p>
<p>否则使用字节流。<strong>如果你不知道该使用哪种类型的流，就使用字节流</strong></p>
</li>
</ul>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2021 爱意随风起
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @phenix-fledgling
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>