
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexo || </title>
    <meta name="author" content="phenix-fledgling">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a href="">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Hexo</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a href="">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hexo</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2021/04/08/零星的问题们/">
        <h2>
            零星的问题们
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="堆内存什么时候被释放？"><a href="#堆内存什么时候被释放？" class="headerlink" title="堆内存什么时候被释放？"></a>堆内存什么时候被释放？</h1><h1 id="怎么调用父类的私有方法呢？（super）"><a href="#怎么调用父类的私有方法呢？（super）" class="headerlink" title="怎么调用父类的私有方法呢？（super）"></a>怎么调用父类的私有方法呢？（super）</h1><h1 id="怎么调用自己的方法呢？（this）"><a href="#怎么调用自己的方法呢？（this）" class="headerlink" title="怎么调用自己的方法呢？（this）"></a>怎么调用自己的方法呢？（this）</h1><h1 id="局部变量指是在局部改一下，存于栈内存，不会对全局变量产生影响！"><a href="#局部变量指是在局部改一下，存于栈内存，不会对全局变量产生影响！" class="headerlink" title="局部变量指是在局部改一下，存于栈内存，不会对全局变量产生影响！"></a>局部变量指是在局部改一下，存于栈内存，不会对全局变量产生影响！</h1><h1 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h1><p>需求：用递归求5的阶乘，并把结果在控制台输出</p>
<p><strong>分析</strong>：</p>
<p>①阶乘：一个正整数的阶乘是所有小于及等于该数的正整数的积，自然数n的阶乘写作n!</p>
<p>​    5! = 5<em>4</em>3<em>2</em>1</p>
<p>②递归出口：1! = 1</p>
<p>③递归规则：n!=n*(n-1)!</p>
<p>​    5! = 5*4!</p>
<p><strong>思路</strong>：</p>
<p>①定义一个方法，用于递归求阶乘，参数为一个int类型的变量</p>
<p>②在方法内部判断该变量的值是否是1</p>
<p>是：返回1</p>
<p>不是：返回n*(n-1)!</p>
<p>③调用方法</p>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = jc(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5的阶乘是：&quot;</span>+ result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> n * jc(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2021/04/08/零星的问题们/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/02/mysql调优/">
        <h2>
            mysql调优
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/2
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="MySQL数据库优化的八种方式-经典必看"><a href="#MySQL数据库优化的八种方式-经典必看" class="headerlink" title="MySQL数据库优化的八种方式(经典必看)"></a>MySQL数据库优化的八种方式(经典必看)</h1><h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 关于数据库优化，网上有不少资料和方法，但是不少质量参差不齐，有些总结的不够到位，内容冗杂</span><br><span class="line">2. 偶尔发现了这篇文章，总结得很经典，文章流量也很大，所以拿到自己的总结文集中，积累优质文章，提升个人能力，希望对大家今后开发中也有帮助</span><br></pre></td></tr></table></figure>

<p>1、选取最适用的字段属性</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>2、使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETEFROMcustomerinfo</span><br><span class="line">WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)</span><br></pre></td></tr></table></figure>

<p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROMcustomerinfo</span><br><span class="line">WHERECustomerIDNOTin(SELECTCustomerIDFROMsalesinfo)</span><br></pre></td></tr></table></figure>

<p>如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROMcustomerinfo</span><br><span class="line">LEFTJOINsalesinfoONcustomerinfo.CustomerID&#x3D;salesinfo.CustomerID</span><br><span class="line">WHEREsalesinfo.CustomerIDISNULL</span><br></pre></td></tr></table></figure>

<p>连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p>
<p>3、使用联合(UNION)来代替手动创建的临时表</p>
<p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECTName,PhoneFROMclientUNION</span><br><span class="line">SELECTName,BirthDateFROMauthorUNION</span><br><span class="line">SELECTName,SupplierFROMproduct</span><br></pre></td></tr></table></figure>

<p>4、事务</p>
<p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">各种各样</a>的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN; INSERTINTOsalesinfoSETCustomerID&#x3D;14;UPDATEinventorySETQuantity&#x3D;11WHEREitem&#x3D;&#39;book&#39;;COMMIT;</span><br></pre></td></tr></table></figure>

<p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p>
<p>5、锁定表</p>
<p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成千上万</a>的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</p>
<p>其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCKTABLEinventoryWRITESELECTQuantityFROMinventoryWHEREItem&#x3D;&#39;book&#39;;</span><br><span class="line">...</span><br><span class="line">UPDATEinventorySETQuantity&#x3D;11WHEREItem&#x3D;&#39;book&#39;;UNLOCKTABLES</span><br></pre></td></tr></table></figure>

<p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。</p>
<p>6、使用外键</p>
<p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p>
<p>例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<ol>
<li><code>CREATETABLEcustomerinfo( CustomerIDINTNOTNULL,PRIMARYKEY(CustomerID))TYPE=INNODB;</code></li>
<li></li>
<li><code>CREATETABLEsalesinfo( SalesIDINTNOTNULL,CustomerIDINTNOTNULL,</code></li>
<li></li>
<li><code>PRIMARYKEY(CustomerID,SalesID),</code></li>
<li></li>
<li><code>FOREIGNKEY(CustomerID)REFERENCEScustomerinfo(CustomerID)ONDELETECASCADE)TYPE=INNODB;</code></li>
</ol>
<p>注意例子中的参数“ONDELETECASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。</p>
<p>7、使用索引</p>
<p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</p>
<p>那该对哪些字段建立索引呢？</p>
<p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</p>
<p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p>
<p>8、优化的查询语句</p>
<p>绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。</p>
<p>下面是应该注意的几个方面。</p>
<ul>
<li><p>首先，最好是在相同类型的字段间进行比较的操作。</p>
<blockquote>
<p>在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。</p>
</blockquote>
</li>
<li><p>其次，在建有索引的字段上尽量不要使用函数进行操作。</p>
</li>
</ul>
<blockquote>
<p>例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。</p>
</blockquote>
<ul>
<li>第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。</li>
</ul>
<p>例如下面的查询将会比较表中的每一条记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<ol>
<li></li>
<li><code>SELECT*FROMbooks</code></li>
<li></li>
<li><code>WHEREnamelike&quot;MySQL%&quot;</code></li>
</ol>
<p>但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<ol>
<li></li>
<li><code>SELECT*FROMbooks</code></li>
<li></li>
<li><code>WHEREname＞=&quot;MySQL&quot;andname＜&quot;MySQM&quot;</code></li>
</ol>
<p>最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。</p>
<h1 id="优化Mysql数据库的8个方法"><a href="#优化Mysql数据库的8个方法" class="headerlink" title="优化Mysql数据库的8个方法"></a>优化Mysql数据库的8个方法</h1><p>本文通过8个方法优化Mysql数据库：创建索引、复合索引、索引不会包含有NULL值的列、使用短索引、排序的索引问题、like语句操作、不要在列上进行运算、不使用NOT IN和&lt;&gt;操作</p>
<p><strong>1、创建索引</strong><br>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。<br><strong>2、复合索引</strong><br>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;<br>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。<br><strong>3、索引不会包含有NULL值的列</strong><br>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。<br><strong>4、使用短索引</strong><br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。<br><strong>5、排序的索引问题</strong><br>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<br><strong>6、like语句操作</strong><br>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。<br><strong>7、不要在列上进行运算</strong><br>select * from users where YEAR(adddate)&lt;2007;<br>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成<br>select * from users where adddate&lt;‘2007-01-01’;<br><strong>8、不使用NOT IN和&lt;&gt;操作</strong><br>NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。</p>
<h1 id="数据库SQL优化大总结之-百万级数据库优化方案"><a href="#数据库SQL优化大总结之-百万级数据库优化方案" class="headerlink" title="数据库SQL优化大总结之 百万级数据库优化方案"></a>数据库SQL优化大总结之 百万级数据库优化方案</h1><p>网上关于SQL优化的教程很多，但是比较杂乱。近日有空整理了一下，写出来跟大家分享一下，其中有错误和不足的地方，还请大家纠正补充。</p>
<p>这篇文章我花费了大量的时间查找资料、修改、排版，希望大家阅读之后，感觉好的话推荐给更多的人，让更多的人看到、纠正以及补充。</p>
<p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure>

<p>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p>
<p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p>
<p>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num &#x3D; 0</span><br></pre></td></tr></table></figure>


<p>3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 or Name &#x3D; &#39;admin&#39;</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num &#x3D; 10</span><br><span class="line">union all</span><br><span class="line">select id from t where Name &#x3D; &#39;admin&#39;</span><br></pre></td></tr></table></figure>


<p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3)</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure>

<p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b)</span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num&#x3D;a.num)</span><br></pre></td></tr></table></figure>

<p>6.下面的查询也将导致全表扫描：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like ‘%abc%’</span><br></pre></td></tr></table></figure>

<p>若要提高效率，可以考虑全文检索。</p>
<p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num &#x3D; @num</span><br></pre></td></tr></table></figure>

<p>可以改为强制查询使用索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t with(index(索引名)) where num &#x3D; @num</span><br></pre></td></tr></table></figure>

<p>.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x2F;2 &#x3D; 100</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num &#x3D; 100*2</span><br></pre></td></tr></table></figure>


<p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3) &#x3D; ’abc’       -–name以abc开头的id</span><br><span class="line">select id from t where datediff(day,createdate,’2005-11-30′) &#x3D; 0    -–‘2005-11-30’    --生成的id</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#39;abc%&#39;</span><br><span class="line">select id from t where createdate &gt;&#x3D; &#39;2005-11-30&#39; and createdate &lt; &#39;2005-12-1&#39;</span><br></pre></td></tr></table></figure>


<p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12.不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2 into #t from t where 1&#x3D;0</span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…)</p>
<p>13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
<p>14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p>
<p>15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p>
<p>16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>20.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>\22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p>
<p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p>29.尽量避免大事务操作，提高系统并发能力。</p>
<p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句<br>　　如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。<br>　　Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。<br>　　如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。<br>　　所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(1)&#123;</span><br><span class="line"></span><br><span class="line"> 　　&#x2F;&#x2F;每次只做1000条</span><br><span class="line"></span><br><span class="line">　　 mysql_query(“delete from logs where log_date &lt;&#x3D; ’2012-11-01’ limit 1000”);</span><br><span class="line"></span><br><span class="line"> 　　if(mysql_affected_rows() &#x3D;&#x3D; 0)&#123;</span><br><span class="line"></span><br><span class="line">　　 　　&#x2F;&#x2F;删除完成，退出！</span><br><span class="line">　　 　　break；</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每次暂停一段时间，释放表让其他进程&#x2F;线程访问。</span><br><span class="line">usleep(50000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里就写完了。我知道还有很多没有写到的，还请大家补充。后面有空会介绍一些SQL优化工具给大家。让我们一起学习，一起进步吧！</p>
<h1 id="运维角度浅谈MySQL数据库优化"><a href="#运维角度浅谈MySQL数据库优化" class="headerlink" title="运维角度浅谈MySQL数据库优化"></a>运维角度浅谈MySQL数据库优化</h1><p> 一个成熟的数据库架构并不是一开始设计就具备高可用、高伸缩等特性的，它是随着用户量的增加，基础架构才逐渐完善。这篇博文主要谈MySQL数据库发展周期中所面临的问题及优化方案，暂且抛开前端应用不说，大致分为以下五个阶段：</p>
<p><strong>1、数据库表设计</strong></p>
<p> 项目立项后，开发部根据产品部需求开发项目，开发工程师工作其中一部分就是对表结构设计。对于数据库来说，这点很重要，如果设计不当，会直接影响访问速度和用户体验。影响的因素很多，比如慢查询、低效的查询语句、没有适当建立索引、数据库堵塞（死锁）等。当然，有测试工程师的团队，会做压力测试，找bug。对于没有测试工程师的团队来说，大多数开发工程师初期不会太多考虑数据库设计是否合理，而是尽快完成功能实现和交付，等项目有一定访问量后，隐藏的问题就会暴露，这时再去修改就不是这么容易的事了。</p>
<p><strong>2、数据库部署</strong></p>
<p> 该运维工程师出场了，项目初期访问量不会很大，所以单台部署足以应对在1500左右的QPS（每秒查询率）。考虑到高可用性，可采用MySQL主从复制+Keepalived做双击热备，常见集群软件有Keepalived、Heartbeat。</p>
<p>双机热备博文：<a target="_blank" rel="noopener" href="http://lizhenliang.blog.51cto.com/7876557/1362313">http://lizhenliang.blog.51cto.com/7876557/1362313</a></p>
<p><strong>3、数据库性能优化</strong></p>
<p> 如果将MySQL部署到普通的X86服务器上，在不经过任何优化情况下，MySQL理论值正常可以处理2000左右QPS，经过优化后，有可能会提升到2500左右QPS，否则，访问量当达到1500左右并发连接时，数据库处理性能就会变慢，而且硬件资源还很富裕，这时就该考虑软件问题了。那么怎样让数据库最大化发挥性能呢？一方面可以单台运行多个MySQL实例让服务器性能发挥到最大化，另一方面是对数据库进行优化，往往操作系统和数据库默认配置都比较保守，会对数据库发挥有一定限制，可对这些配置进行适当的调整，尽可能的处理更多连接数。</p>
<p>具体优化有以下三个层面：</p>
<p> <strong>3.1 数据库配置优化</strong></p>
<p> MySQL常用有两种存储引擎，一个是MyISAM，不支持事务处理，读性能处理快，表级别锁。另一个是InnoDB，支持事务处理（ACID），设计目标是为处理大容量数据发挥最大化性能，行级别锁。</p>
<p> 表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。</p>
<p> 行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。</p>
<p> 为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。</p>
<p> 根据以上看来，使用InnoDB存储引擎是最好的选择，也是MySQL5.5以后版本中默认存储引擎。每个存储引擎相关联参数比较多，以下列出主要影响数据库性能的参数。</p>
<p> 公共参数默认值：</p>
<table>
<thead>
<tr>
<th>123456</th>
<th><code>max_connections = 151``#同时处理最大连接数，推荐设置最大连接数是上限连接数的80%左右  ``sort_buffer_size = 2M``#查询排序时缓冲区大小，只对order by和group by起作用，可增大此值为16M``open_files_limit = 1024 ``#打开文件数限制，如果show global status like &#39;open_files&#39;查看的值等于或者大于open_files_limit值时，程序会无法连接数据库或卡死</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> MyISAM参数默认值：</p>
<table>
<thead>
<tr>
<th>12345678910</th>
<th><code>key_buffer_size = 16M``#索引缓存区大小，一般设置物理内存的30-40%``read_buffer_size = 128K ``#读操作缓冲区大小，推荐设置16M或32M``query_cache_type = ON``#打开查询缓存功能``query_cache_limit = 1M ``#查询缓存限制，只有1M以下查询结果才会被缓存，以免结果数据较大把缓存池覆盖``query_cache_size = 16M ``#查看缓冲区大小，用于缓存SELECT查询结果，下一次有同样SELECT查询将直接从缓存池返回结果，可适当成倍增加此值</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> InnoDB参数默认值：</p>
<table>
<thead>
<tr>
<th>12345678910</th>
<th><code>innodb_buffer_pool_size = 128M``#索引和数据缓冲区大小，一般设置物理内存的60%-70%``innodb_buffer_pool_instances = 1  ``#缓冲池实例个数，推荐设置4个或8个``innodb_flush_log_at_trx_commit = 1 ``#关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。``innodb_file_per_table = OFF ``#默认是共享表空间，共享表空间idbdata文件不断增大，影响一定的I/O性能。推荐开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。``innodb_log_buffer_size = 8M ``#日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> <strong>3.2 系统内核优化</strong></p>
<p> 大多数MySQL都部署在linux系统上，所以操作系统的一些参数也会影响到MySQL性能，以下对linux内核进行适当优化。</p>
<table>
<thead>
<tr>
<th>12345678910</th>
<th><code>net.ipv4.tcp_fin_timeout = 30``#TIME_WAIT超时时间，默认是60s``net.ipv4.tcp_tw_reuse = 1  ``#1表示开启复用，允许TIME_WAIT socket重新用于新的TCP连接，0表示关闭``net.ipv4.tcp_tw_recycle = 1 ``#1表示开启TIME_WAIT socket快速回收，0表示关闭``net.ipv4.tcp_max_tw_buckets = 4096  ``#系统保持TIME_WAIT socket最大数量，如果超出这个数，系统将随机清除一些TIME_WAIT并打印警告信息``net.ipv4.tcp_max_syn_backlog = 4096``#进入SYN队列最大长度，加大队列长度可容纳更多的等待连接</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 在linux系统中，如果进程打开的文件句柄数量超过系统默认值1024，就会提示“too many files open”信息，所以要调整打开文件句柄限制。</p>
<table>
<thead>
<tr>
<th>1234</th>
<th><code># vi /etc/security/limits.conf #加入以下配置，*代表所有用户，也可以指定用户，重启系统生效``* soft nofile 65535``* hard nofile 65535``# ulimit -SHn 65535  #立刻生效</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> <strong>3.3 硬件配置</strong></p>
<p> 加大物理内存，提高文件系统性能。linux内核会从内存中分配出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。也就是说物理内存越大，分配缓存区越大，缓存数据越多。当然，服务器故障会丢失一定的缓存数据。</p>
<p> SSD硬盘代替SAS硬盘，将RAID级别调整为RAID1+0，相对于RAID1和RAID5有更好的读写性能（IOPS），毕竟数据库的压力主要来自磁盘I/O方面。</p>
<p><strong>4、数据库架构扩展</strong></p>
<p> 随着业务量越来越大，单台数据库服务器性能已无法满足业务需求，该考虑加机器了，该做集群了~~~。主要思想是分解单台数据库负载，突破磁盘I/O性能，热数据存放缓存中，降低磁盘I/O访问频率。</p>
<p> <strong>4.1 主从复制与读写分离</strong></p>
<p> 因为生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，主流的负载均衡器有LVS、HAProxy、Nginx。</p>
<p> 怎么来实现读写分离呢？大多数企业是在代码层面实现读写分离，效率比较高。另一个种方式通过代理程序实现读写分离，企业中应用较少，常见代理程序有MySQL Proxy、Amoeba。在这样数据库集群架构中，大大增加数据库高并发能力，解决单台性能瓶颈问题。如果从数据库一台从库能处理2000 QPS，那么5台就能处理1w QPS，数据库横向扩展性也很容易。</p>
<p> 有时，面对大量写操作的应用时，单台写性能达不到业务需求。如果做双主，就会遇到数据库数据不一致现象，产生这个原因是在应用程序不同的用户会有可能操作两台数据库，同时的更新操作造成两台数据库数据库数据发生冲突或者不一致。在单库时MySQL利用存储引擎机制表锁和行锁来保证数据完整性，怎样在多台主库时解决这个问题呢？有一套基于perl语言开发的主从复制管理工具，叫MySQL-MMM（Master-Master replication managerfor Mysql，Mysql主主复制管理器），这个工具最大的优点是在同一时间只提供一台数据库写操作，有效保证数据一致性。</p>
<p> 主从复制博文：<a target="_blank" rel="noopener" href="http://lizhenliang.blog.51cto.com/7876557/1290431">http://lizhenliang.blog.51cto.com/7876557/1290431</a></p>
<p> 读写分离博文：<a target="_blank" rel="noopener" href="http://lizhenliang.blog.51cto.com/7876557/1305083">http://lizhenliang.blog.51cto.com/7876557/1305083</a></p>
<p> MySQL-MMM博文：<a target="_blank" rel="noopener" href="http://lizhenliang.blog.51cto.com/7876557/1354576">http://lizhenliang.blog.51cto.com/7876557/1354576</a></p>
<p> <strong>4.2 增加缓存</strong></p>
<p> 给数据库增加缓存系统，把热数据缓存到内存中，如果缓存中有要请求的数据就不再去数据库中返回结果，提高读性能。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中。分布式缓存可以缓存海量数据，扩展性好，主流的分布式缓存系统有memcached、redis，memcached性能稳定，数据缓存在内存中，速度很快，QPS可达8w左右。如果想数据持久化就选择用redis，性能不低于memcached。</p>
<p> 工作过程：</p>
<p> <a target="_blank" rel="noopener" href="http://s3.51cto.com/wyfs02/M02/6D/E6/wKiom1VukrqyM-JcAABPhCy-LOM409.jpg"><img src="http://s3.51cto.com/wyfs02/M02/6D/E6/wKiom1VukrqyM-JcAABPhCy-LOM409.jpg" alt="wKiom1VukrqyM-JcAABPhCy-LOM409.jpg"></a></p>
<p> <strong>4.3 分库</strong></p>
<p> 分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。</p>
<p> <strong>4.4 分表</strong></p>
<p> 数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，怎么能解决单表压力呢？你就该考虑是否把这个表拆分成多个小表，来减轻单个表的压力，提高处理效率，此方式称为分表。</p>
<p> 分表技术比较麻烦，要修改程序代码里的SQL语句，还要手动去创建其他表，也可以用merge存储引擎实现分表，相对简单许多。分表后，程序是对一个总表进行操作，这个总表不存放数据，只有一些分表的关系，以及更新数据的方式，总表会根据不同的查询，将压力分到不同的小表上，因此提高并发能力和磁盘I/O性能。</p>
<p> 分表分为垂直拆分和水平拆分：</p>
<p> 垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。</p>
<p> 水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。</p>
<p> <strong>4.5 分区</strong></p>
<p> 分区就是把一张表的数据根据表结构中的字段（如range、list、hash等）分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。</p>
<p>注：增加缓存、分库、分表和分区主要由程序猿来实现。</p>
<p><strong>5、数据库维护</strong></p>
<p> 数据库维护是运维工程师或者DBA主要工作，包括性能监控、性能分析、性能调优、数据库备份和恢复等。</p>
<p> <strong>5.1 性能状态关键指标</strong></p>
<p> QPS，Queries Per Second：每秒查询数，一台数据库每秒能够处理的查询次数</p>
<p> TPS，Transactions Per Second：每秒处理事务数</p>
<p> 通过show status查看运行状态，会有300多条状态信息记录，其中有几个值帮可以我们计算出QPS和TPS，如下：</p>
<p> Uptime：服务器已经运行的实际，单位秒</p>
<p> Questions：已经发送给数据库查询数</p>
<p> Com_select：查询次数，实际操作数据库的</p>
<p> Com_insert：插入次数</p>
<p> Com_delete：删除次数</p>
<p> Com_update：更新次数</p>
<p> Com_commit：事务次数</p>
<p> Com_rollback：回滚次数</p>
<p> 那么，计算方法来了，基于Questions计算出QPS：</p>
<table>
<thead>
<tr>
<th>12</th>
<th><code> ``mysql&gt; show global status like ``&#39;Questions&#39;``;`` ``mysql&gt; show global status like ``&#39;Uptime&#39;``;</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> QPS = Questions / Uptime</p>
<p> 基于Com_commit和Com_rollback计算出TPS：</p>
<table>
<thead>
<tr>
<th>123</th>
<th><code> ``mysql&gt; show global status like ``&#39;Com_commit&#39;``;`` ``mysql&gt; show global status like ``&#39;Com_rollback&#39;``;`` ``mysql&gt; show global status like ``&#39;Uptime&#39;``;</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> TPS = (Com_commit + Com_rollback) / Uptime</p>
<p> 另一计算方式：基于Com_select、Com_insert、Com_delete、Com_update计算出QPS</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code> ``mysql&gt; show global status where Variable_name ``in``(``&#39;com_select&#39;``,``&#39;com_insert&#39;``,``&#39;com_delete&#39;``,``&#39;com_update&#39;``);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 等待1秒再执行，获取间隔差值，第二次每个变量值减去第一次对应的变量值，就是QPS</p>
<p> TPS计算方法：</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code> ``mysql&gt; show global status where Variable_name ``in``(``&#39;com_insert&#39;``,``&#39;com_delete&#39;``,``&#39;com_update&#39;``);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 计算TPS，就不算查询操作了，计算出插入、删除、更新四个值即可。</p>
<p> 经网友对这两个计算方式的测试得出，当数据库中myisam表比较多时，使用Questions计算比较准确。当数据库中innodb表比较多时，则以Com_*计算比较准确。</p>
<p> <strong>5.2 开启慢查询日志</strong></p>
<p> MySQL开启慢查询日志，分析出哪条SQL语句比较慢，使用set设置变量，重启服务失效，可以在my.cnf添加参数永久生效。</p>
<table>
<thead>
<tr>
<th>1234</th>
<th><code>mysql&gt; ``set</code> <code>global slow-query-log=on ``#开启慢查询功能``mysql&gt; ``set</code> <code>global slow_query_log_file=``&#39;/var/log/mysql/mysql-slow.log&#39;``; ``#指定慢查询日志文件位置``mysql&gt; ``set</code> <code>global log_queries_not_using_indexes=on;  ``#记录没有使用索引的查询``mysql&gt; ``set</code> <code>global long_query_time=1;  ``#只记录处理时间1s以上的慢查询</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 分析慢查询日志，可以使用MySQL自带的mysqldumpslow工具，分析的日志较为简单。</p>
<p> # mysqldumpslow -t 3 /var/log/mysql/mysql-slow.log   #查看最慢的前三个查询</p>
<p> 也可以使用percona公司的pt-query-digest工具，日志分析功能全面，可分析slow log、binlog、general log。</p>
<p> 分析慢查询日志：pt-query-digest /var/log/mysql/mysql-slow.log</p>
<p> 分析binlog日志：mysqlbinlog mysql-bin.000001 &gt;mysql-bin.000001.sql </p>
<p> pt-query-digest –type=binlog mysql-bin.000001.sql </p>
<p> 分析普通日志：pt-query-digest –type=genlog localhost.log</p>
<p> <strong>5.3 数据库备份</strong></p>
<p> 备份数据库是最基本的工作，也是最重要的，否则后果很严重，你懂得！但由于数据库比较大，上百G，往往备份都很耗费时间，所以就该选择一个效率高的备份策略，对于数据量大的数据库，一般都采用增量备份。常用的备份工具有mysqldump、mysqlhotcopy、xtrabackup等，mysqldump比较适用于小的数据库，因为是逻辑备份，所以备份和恢复耗时都比较长。mysqlhotcopy和xtrabackup是物理备份，备份和恢复速度快，不影响数据库服务情况下进行热拷贝，建议使用xtrabackup，支持增量备份。</p>
<p> Xtrabackup备份工具使用博文：<a target="_blank" rel="noopener" href="http://lizhenliang.blog.51cto.com/7876557/1612800">http://lizhenliang.blog.51cto.com/7876557/1612800</a></p>
<p> <strong>5.4 数据库修复</strong></p>
<p> 有时候MySQL服务器突然断电、异常关闭，会导致表损坏，无法读取表数据。这时就可以用到MySQL自带的两个工具进行修复，myisamchk和mysqlcheck。</p>
<p> myisamchk：只能修复myisam表，需要停止数据库</p>
<p> 常用参数：</p>
<p> -f –force   强制修复，覆盖老的临时文件，一般不使用</p>
<p> -r –recover  恢复模式</p>
<p> -q –quik   快速恢复</p>
<p> -a –analyze  分析表</p>
<p> -o –safe-recover 老的恢复模式，如果-r无法修复，可以使用此参数试试</p>
<p> -F –fast   只检查没有正常关闭的表</p>
<p> 快速修复weibo数据库:</p>
<p> # cd /var/lib/mysql/weibo </p>
<p> # myisamchk -r -q *.MYI</p>
<p> mysqlcheck：myisam和innodb表都可以用，不需要停止数据库，如修复单个表，可在数据库后面添加表名，以空格分割</p>
<p> 常用参数：</p>
<p> -a  –all-databases  检查所有的库</p>
<p> -r  –repair  修复表</p>
<p> -c  –check   检查表，默认选项</p>
<p> -a  –analyze  分析表</p>
<p> -o  –optimize 优化表</p>
<p> -q  –quik  最快检查或修复表</p>
<p> -F  –fast  只检查没有正常关闭的表</p>
<p> 快速修复weibo数据库:</p>
<p> mysqlcheck -r -q -uroot -p123 weibo </p>
<p> 5.5 另外，查看CPU和I/O性能方法</p>
<p> #查看CPU性能</p>
<p><img src="http://s3.51cto.com/wyfs02/M02/6D/D9/wKiom1VtPFmCEtY9AADbdiZbn9A400.jpg" alt="wKiom1VtPFmCEtY9AADbdiZbn9A400.jpg"></p>
<p> #参数-P是显示CPU数，ALL为所有，也可以只显示第几颗CPU<img src="http://s3.51cto.com/wyfs02/M00/6D/D5/wKioL1VtPpayB7WeAALQHX41buc367.jpg" alt="wKioL1VtPpayB7WeAALQHX41buc367.jpg"></p>
<p> #查看I/O性能</p>
<p><a target="_blank" rel="noopener" href="http://s3.51cto.com/wyfs02/M00/6D/D9/wKiom1VtPSXTsI4zAAMkfVf2r-I743.jpg"><img src="http://s3.51cto.com/wyfs02/M00/6D/D9/wKiom1VtPSXTsI4zAAMkfVf2r-I743.jpg" alt="wKiom1VtPSXTsI4zAAMkfVf2r-I743.jpg"></a></p>
<p> #参数-m是以M单位显示，默认K</p>
<p> #%util：当达到100%时，说明I/O很忙。</p>
<p> #await：请求在队列中等待时间，直接影响read时间。</p>
<p> I/O极限：IOPS（r/s+w/s）,一般RAID0/10在1200左右。（IOPS，每秒进行读写（I/O）操作次数）</p>
<p> I/O带宽：在顺序读写模式下SAS硬盘理论值在300M/s左右，SSD硬盘理论值在600M/s左右。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/mysql调优" style=color:#ffa2c4>
                mysql调优
            </a>
        </span>
        
    </div>

    <a href="/2021/04/02/mysql调优/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/02/jvm调优/">
        <h2>
            jvm调优
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/2
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="一、JVM内存调优"><a href="#一、JVM内存调优" class="headerlink" title="一、JVM内存调优"></a><strong>一、JVM内存调优</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-c256a1d88bd0a626a4583778d2c13bc9_720w.jpg" alt="img"></p>
<p><strong>对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。</strong></p>
<p><strong>1.Full GC</strong></p>
<p>会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。</p>
<p><strong>2.导致Full GC的原因</strong></p>
<p><strong>1)*年老代（Tenured）被写满*</strong></p>
<p>调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。</p>
<p><strong>2)持久代Pemanet Generation空间不足</strong></p>
<p>增大Perm Gen空间，避免太多静态对象 ， 控制好新生代和旧生代的比例</p>
<p><strong>3)System.gc()被显示调用</strong></p>
<p>垃圾回收不要手动触发，尽量依靠JVM自身的机制</p>
<p><strong>在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节，下面详细介绍对应JVM调优的方法和步骤。</strong></p>
<h2 id="二、JVM性能调优方法和步骤"><a href="#二、JVM性能调优方法和步骤" class="headerlink" title="二、JVM性能调优方法和步骤"></a><strong>二、JVM性能调优方法和步骤</strong></h2><p><img src="https://pic1.zhimg.com/80/v2-5e1966122f124e4034a4c4f281cf7458_720w.jpg" alt="img"></p>
<p><strong>1.监控GC的状态</strong></p>
<p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。</p>
<p><strong>举一个例子： 系统崩溃前的一些现象：</strong></p>
<ul>
<li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li>
<li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li>
<li>年老代的内存越来越大并且每次FullGC后年老代没有内存被释放</li>
</ul>
<p>之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。</p>
<p><strong>2.生成堆的dump文件</strong></p>
<p>通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。</p>
<p><strong>3.分析dump文件</strong></p>
<p>打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux，几种工具打开该文件：</p>
<ul>
<li>Visual VM</li>
<li>IBM HeapAnalyzer</li>
<li>JDK 自带的Hprof工具</li>
<li><strong>Mat(Eclipse专门的静态内存分析工具)推荐使用</strong></li>
</ul>
<p>备注：文件太大，建议使用Eclipse专门的静态内存分析工具Mat打开分析。</p>
<p><strong>4.分析结果，判断是否需要优化</strong></p>
<p>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。</p>
<p><strong>注：如果满足下面的指标，则一般不需要进行GC：</strong></p>
<ul>
<li>Minor GC执行时间不到50ms；</li>
<li>Minor GC执行不频繁，约10秒一次；</li>
<li>Full GC执行时间不到1s；</li>
<li>Full GC执行频率不算频繁，不低于10分钟1次；</li>
</ul>
<p><strong>5.调整GC类型和内存分配</strong></p>
<p>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p>
<p><strong>6.不断的分析和调整</strong></p>
<p>通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些<strong>参数应用到所有服务器。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-1acebd36d4d6777d87e594c1572c11ba_720w.jpg" alt="img"></p>
<p>cms参数优化步流程</p>
<p><strong>下面我再继续介绍下JVM的关键参数配置(仅用于参考)。</strong></p>
<h2 id="JVM调优参数参考"><a href="#JVM调优参数参考" class="headerlink" title="JVM调优参数参考"></a>JVM调优参数参考</h2><p>1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，<strong>为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;</strong></p>
<p><strong>2.年轻代和年老代将根据默认的比例（1：2）分配堆内存</strong>， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。</p>
<p>比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。</p>
<p>3.年轻代和年老代设置多大才算合理</p>
<p><strong>1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC</strong></p>
<p><strong>2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</strong></p>
<p>如何选择应该依赖应用程序<strong>对象生命周期的分布情况</strong>： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。</p>
<p><strong>在抉择时应该根 据以下两点：</strong></p>
<p>（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。</p>
<p>（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。</p>
<p><strong>4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法</strong>： <strong>-XX:+UseParallelOldGC</strong> <strong>。</strong></p>
<p><strong>5.线程堆栈的设置</strong>：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。</p>
<p>理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/jvm调优" style=color:#ffa2c4>
                jvm调优
            </a>
        </span>
        
    </div>

    <a href="/2021/04/02/jvm调优/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/02/tomcat调优/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/2
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="title-tomcat调优"><a href="#title-tomcat调优" class="headerlink" title="title: tomcat调优"></a>title: tomcat调优</h2><p>date: 2021-04-02 16:46:34<br>tags: tomcat调优</p>
<h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a><strong>一、描述</strong></h1><p>最近，在补充自己的短板，刚好整理到<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485487&idx=2&sn=614b2cbce66acfd2361c7024f521cf35&chksm=fe7959f7c90ed0e14f8037f3ff3f132aa4c9097d5656f9ae9a8cacefae2d8b09d16d90820482&scene=21#wechat_redirect"> Tomcat 调优</a>这块，基本上面试必问，于是就花了点时间去搜集一下 Tomcat 调优都调了些什么，先记录一下调优手段，更多详细的原理和实现以后用到时候再来补充记录，下面就来介绍一下，Tomcat 调优大致分为两大类。</p>
<h2 id="1、Tomcat的自身调优"><a href="#1、Tomcat的自身调优" class="headerlink" title="1、Tomcat的自身调优"></a><strong>1、Tomcat的自身调优</strong></h2><p>采用动静分离节约 Tomcat 的性能</p>
<p>调整 Tomcat 的线程池</p>
<p>调整 Tomcat 的连接器</p>
<p>修改 Tomcat 的运行模式</p>
<p>禁用 AJP 连接器</p>
<h2 id="2、JVM的调优"><a href="#2、JVM的调优" class="headerlink" title="2、JVM的调优"></a><strong>2、JVM的调优</strong></h2><p>调优jvm内存</p>
<h1 id="二、Tomcat-自身调优"><a href="#二、Tomcat-自身调优" class="headerlink" title="二、Tomcat 自身调优"></a><strong>二、Tomcat 自身调优</strong></h1><h2 id="1、采用动静分离"><a href="#1、采用动静分离" class="headerlink" title="1、采用动静分离"></a><strong>1、采用动静分离</strong></h2><p>静态资源如果让<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485556&idx=3&sn=4d4b240eefa802b398f2e6b47a6957ca&chksm=fe7959acc90ed0ba4aed31874fe0dbde62e1af19670ea349d68dba804b14d27d402d049343dd&scene=21#wechat_redirect"> Tomcat 处理</a>的话 Tomcat 的性能会被损耗很多，所以我们一般都是采用：Nginx+Tomcat 实现动静分离，让 Tomcat 只负责 jsp 文件的解析工作，Nginx 实现静态资源的访问。</p>
<h2 id="2、调优-Tomcat-线程池"><a href="#2、调优-Tomcat-线程池" class="headerlink" title="2、调优 Tomcat 线程池"></a><strong>2、调优 Tomcat 线程池</strong></h2><p>打开tomcat的serve.xml，配置Executor，相关参数说明如下。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eaMr9cKHOkFXzBnBmNrYJk4srZOWxLd8fTj53XIwT5NhziaPiaA9FCBxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>name</strong>：给执行器（线程池）起一个名字；</p>
<p><strong>namePrefix</strong>：指定线程池中的每一个线程的 name 前缀；</p>
<p><strong>maxThreads</strong>：线程池中最大的线程数量，假设请求的数量超过了 750，这将不是意味着将 maxThreads 属性值设置为 750，它的最好解决方案是使用「Tomcat集群」。也就是说，如果有 1000 请求，两个 Tomcat 实例设置 maxThreads = 500，而不在单 Tomcat 实例的情况下设置 maxThreads=1000。</p>
<p><strong>minSpareThreads</strong>：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485480&idx=3&sn=c95756a9ea720d73d35540e6791514d1&chksm=fe7959f0c90ed0e6c430895737a1f36bb6d3bf43c3bb3f548d3309ba5a6ef67bcc36e41f53ff&scene=21#wechat_redirect">线程池中</a>允许空闲的线程数量（多余的线程都杀死）；</p>
<p><strong>maxIdLeTime</strong>：一个线程空闲多久算是一个空闲线程；</p>
<p>其他的配置其实阅读官方文档是最好的「见参考链接」。</p>
<h2 id="3、调优-Tomcat-的连接器-Connector"><a href="#3、调优-Tomcat-的连接器-Connector" class="headerlink" title="3、调优 Tomcat 的连接器 Connector"></a><strong>3、调优 Tomcat 的连接器 Connector</strong></h2><p>打开 Tomcat 的 serve.xml，配置 Connector，参数说明如下。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eiaWjmYkqmFb0aasaAIuHJDJ3WcfrspyWmIetMibasv4ibjhWfmGGtXvmg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>executor：指定这个连接器所使用的执行器（线程池）；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eDjrMWf0OAUl8zH8qCGK9TUPTQ7PxFvl2uCl8Uvh7ozcpTkAIk0gmPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>enableLookups=false</strong>：关闭 DNS 解析，减少性能损耗；</p>
<p><strong>minProcessors</strong>：服务器启动时创建的最少线程数；</p>
<p><strong>maxProcessors</strong>：最大可以创建的线程数；</p>
<p><strong>acceptCount=1000</strong>：线程池中的线程都被占用，允许放到队列中的请求数；</p>
<p><strong>maxThreads=3000</strong>：最大线程数；</p>
<p><strong>minSpareThreads=20</strong>：最小空闲线程数，这里是一直会运行的线程；</p>
<p><strong>与压缩有关系的配置</strong>：如果已经对代码进行了动静分离，静态页面和图片等数据就不需要 Tomcat 处理了，那么也就不需要配置在 Tomcat 中配置压缩了；</p>
<p>一个完整的配置如下。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eibbsMVvvy9OV0KHsobSIGoQbXbMyicXEke0ia2yiaoKfkrC0b9YhKBhZwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="4、通过修改-Tomcat-的运行模式"><a href="#4、通过修改-Tomcat-的运行模式" class="headerlink" title="4、通过修改 Tomcat 的运行模式"></a><strong>4、通过修改 Tomcat 的运行模式</strong></h2><p><strong>BIO</strong></p>
<p>Tomcat8 以下版本，默认使用的就是 BIO「<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247484671&idx=2&sn=5f741a1c649d3fd1b1fd447f3ed5176b&chksm=fe795527c90edc31bfc1dacdc93443b66d493f9c8068da942a77f8edfdb15783e369d6545ae8&scene=21#wechat_redirect">阻塞式IO</a>)」模式。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eP8DnfFuLR00yoz9vbfeYsOY2ayfFhVz27NytfpkYPccthSgvTATjuA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对于每一个请求都要创建一个线程来进行处理，不适合高并发。</p>
<p><strong>NIO</strong></p>
<p>Tomcat8 以上版本，默认使用的就是NIO模式「非阻塞式 IO」。</p>
<p><strong>APR</strong></p>
<p>全称 Apache Portable Runtime，是Tomcat生产环境运行的首选方式，如果操作系统未安装 APR 或者 APR 路径未指到<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485545&idx=3&sn=ba1a4da11310d2e6e2bd6d817fe4695c&chksm=fe7959b1c90ed0a737adbb9d9475d4f4c7d04683249951448aa71b1266f01e80bdf135dd3cda&scene=21#wechat_redirect"> Tomcat 默认</a>可识别的路径，则 APR 模式无法启动，自动切换启动 NIO 模式。所以必须要安装 APR 和 Native，直接启动就支持 APR，APR是从操作系统级别解决异步 IO 问题，APR 的本质就是使用 JNI 技术调用操作系统底层的 IO 接口，所以需要提前安装所需要的依赖</p>
<p>提升 Tomcat 对静态文件的处理性能，当然也可以采用动静分离。</p>
<h2 id="5、禁用-AJP-连接器"><a href="#5、禁用-AJP-连接器" class="headerlink" title="5、禁用 AJP 连接器"></a><strong>5、禁用 AJP 连接器</strong></h2><p>AJP的全称 Apache JServer Protocol，使用 Nginx+Tomca t的架构，所以用不着 AJP 协议，所以把AJP连接器禁用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eeO43E3Qc1E0CpSNYj2UGfL3IekLPNFPnJC3ricickb26pOgDbHoJEKIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>三、JVM 调优</strong></p>
<p>Tomcat 是运行在 JVM 上的，所以对 JVM 的调优也是非常有必要的。</p>
<p>找到 catalina.sh；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2e5Vn6VProqfpRggbTiah2jK6oh6CV3ib9pJEHo99ANOIzic9CZkBS9ndRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>添加；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/bcPwoCALib9Kq5ia9Pk8NVHhwxDARqSx2eib8js0Cw3GvGRc8fxO7aib1ria704xictV1s1ZVkcUpMhRnq0Z1VMtLiayw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>参数设置；</p>
<blockquote>
<p>JAVA_OPTS=”-Djava.awt.headless=true -Dfile.encoding=UTF-8-server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XXermSize=512m -XX:MaxPermSize=512m -XX:+DisableExplicitGC”</p>
</blockquote>
<p>调整堆大小的的目的是最小化垃圾收集的时间，以在特定的时间内最大化处理客户的请求。</p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-8.0-doc/config/executor.html">https://tomcat.apache.org/tomcat-8.0-doc/config/executor.html</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-8.0-doc/config/index.html">https://tomcat.apache.org/tomcat-8.0-doc/config/index.html</a></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2021/04/02/tomcat调优/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/02/Linux性能调优/">
        <h2>
            Linux性能调优
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/2
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a>一、前提</h1><p>我们可以在文章的开始就列出一个列表，列出可能影响Linux操作系统性能的一些调优参数，但这样做其实并没有什么价值。因为性能调优是一个非常困难的任务，它要求对硬件、操作系统、和应用都有着相当深入的了解。如果性能调优非常简单的话，那些我们要列出的调优参数早就写入硬件的微码或者操作系统中了，我们就没有必要再继续读这篇文章了。正如下图所示，服务器的性能受到很多因素的影响。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMAkYRPibWD4k8q7EXhnHAOEhiczcjBMTXA7Zx1cTWib36WdTic82l4ZRqQiaw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当面对一个使用单独IDE硬盘的，有20000用户的数据库服务器时，即使我们使用数周时间去调整I/O子系统也是徒劳无功的，通常一个新的驱动或者应用程序的一个更新（如SQL优化）却可以使这个服务器的性能得到明显的提升。正如我们前面提到的，不要忘记系统的性能是受多方面因素影响的。理解操作系统管理系统资源的方法将帮助我们在面对问题时更好的判断应该对哪个子系统进行调整。</p>
<h1 id="二、Linux的CPU调度"><a href="#二、Linux的CPU调度" class="headerlink" title="二、Linux的CPU调度"></a><strong>二、Linux的CPU调度</strong></h1><p>任何计算机的基本功能都十分简单，那就是计算。为了实现计算的功能就必须有一个方法去管理计算资源、处理器和计算任务（也被叫做线程或者进程）。非常感谢Ingo Molnar，他为Linux内核带来了O（1）CPU调度器，区别于旧有的O（n）调度器，新的调度器是动态的，可以支持负载均衡，并以恒定的速度进行操作。</p>
<p>新调度器的可扩展性非常好，无论进程数量或者处理器数量，并且调度器本身的系统开销更少。新调取器的算法使用两个优先级队列。</p>
<p>・活动运行队列</p>
<p>・过期运行队列</p>
<p>调度器的一个重要目标是根据优先级权限有效地为进程分配CPU 时间片，当分配完成后它被列在CPU的运行队列中，除了 CPU 的运行队列之外，还有一个过期运行队列。当活动运行队列中的一个任务用光自己的时间片之后，它就被移动到过期运行队列中。在移动过程中，会对其时间片重新进行计算。如果活动运行队列中已经没有某个给定优先级的任务了，那么指向活动运行<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247484705&idx=3&sn=a92401c2e99375866fc5a18dfa8f62b1&chksm=fe7954f9c90eddef5e6a0f011378fb890fca9f008e87e22d612d1db192881ba4a7463f314830&scene=21#wechat_redirect">队列和</a>过期运行队列的指针就会交换，这样就可以让过期优先级列表变成活动优先级的列表。通常交互式进程（相对与实时进程而言）都有一个较高的优先级，它占有更长的时间片，比低优先级的进程获得更多的计算时间，但通过调度器自身的调整并不会使低优先级的进程完全被饿死。新调度器的优势是显著的改变Linux内核的可扩展性，使新内核可以更好的处理一些有大量进程、大量处理器组成的企业级应用。新的O(1)调度器包含仔2.6内核中，但是也向下兼容2.4内核。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMAnCGGL0pek76VfvZFDPjdPKPmH1cLWY5RRgNj4Zs8vwm2MqIDaDyGbQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>调度器另外一个重要的优势是体现在对NUMA(non-uniform memory architecture)和SMP（symmetric multithreading processors）的支持上，例如INTEL@的超线程技术</p>
<p>改进的NUMA支持保证了负载均衡不会发生在CECs或者NUMA节点之间，除非发生一个节点的超出负载限度</p>
<h1 id="三、Linux的内存架构"><a href="#三、Linux的内存架构" class="headerlink" title="三、Linux的内存架构"></a><strong>三、Linux的内存架构</strong></h1><p>今天我们面对选择32位操作<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247486076&idx=1&sn=42cff3e231ef83824fdb34829de14e7f&chksm=fe795ba4c90ed2b245255ea7cb5cea6ce8804b64ab6306946dea9dcbfd526e68938bf646c346&scene=21#wechat_redirect">系统还</a>是64位操作系统的情况。对企业级用户它们之间最大的区别是64位操作系统可以支持大于4GB的内存寻址。从性能角度来讲，我们需要了解32位和64位操作系统都是如何进行物理内存和虚拟内存的映射的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMAyM0gQ5Y99vQBeAibc4EbH1AhdnU1GFRvZ9505CrGYjTIohzib5Ffias4w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在上面图示中我们可以看到64位和32位Linux内核在寻址上有着显著的不同。</p>
<p>在32位架构中，比如IA-32，Linux内核可以直接寻址的范围只有物理内存的第一个GB（如果去掉保留部分还剩下896MB），访问内存必须被映射到这小于1GB的所谓ZONE_NORMAL空间中，这个操作是由应用程序完成的。但是分配在ZONE_HIGHMEM中的内存页将导致性能的降低。</p>
<p>在另一方面，64位架构比如x86-64（也称作EM64T或者AMD64）。ZONE_NORMAL空间将扩展到64GB或者128GB（实际上可以更多，但是这个数值受到操作系统本身支持内存容量的限制）。正如我们看到的，使用64位操作系统我们排除了因ZONE_HIGHMEM部分内存对性能的影响的情况。</p>
<p>实际中，在32位架构下，由于上面所描述的内存寻址问题，对于大内存，高负载应用，会导致死机或严重缓慢等问题。虽然使用hugemen核心可缓解，但采取x86_64架构是最佳的解决办法。</p>
<h1 id="四、虚拟内存管理"><a href="#四、虚拟内存管理" class="headerlink" title="四、虚拟内存管理"></a><strong>四、虚拟内存管理</strong></h1><p>因为操作系统将内存都映射为虚拟内存，所以操作系统的物理内存结构对用户和应用来说通常都是不可见的。如果想要理解Linux系统内存的调优，我们必须了解Linux的虚拟<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485874&idx=2&sn=6533223eb96122e2c21f8a833b626c02&chksm=fe79586ac90ed17cb4896e94343f9b34a674e9540a6144954fa2e74f3fbe4191cc1e9bd8f34c&scene=21#wechat_redirect">内存机制</a>。应用程序并不分配物理内存，而是向Linux内核请求一部分映射为虚拟内存的内存空间。如下图所示虚拟内存并不一定是映射物理内存中的空间，如果应用程序有一个大容量的请求，也可能会被映射到在磁盘子系统中的swap空间中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMAaEHnkqeBU82ZG834ZgkWiaFh2KzmiawMxfobfuPzvWLppa3hF7oLMU3A/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>另外要提到的是，通常应用程序不直接将数据写到磁盘子系统中，而是写入缓存和缓冲区中。Bdflush守护进程将定时将缓存或者缓冲区中的数据写到硬盘上。</p>
<p>Linux内核处理数据写入磁盘子系统和管理磁盘缓存是紧密联系在一起的。相对于其他的操作系统都是在内存中分配指定的一部分作为磁盘缓存，Linux处理内存更加有效，默认情况下虚拟内存管理器分配所有可用内存空间作为磁盘缓存，这就是为什么有时我们观察一个配置有数G内存的Linux系统可用内存只有20MB的原因。</p>
<p>同时Linux使用swap空间的机制也是相当高效率的，如上图所示虚拟内存空间是由物理内存和磁盘子系统中的swap空间共同组成的。如果虚拟内存管理器发现一个已经分配完成的内存分页已经长时间没有被调用，它将把这部分内存分页移到swap空间中。经常我们会发现一些守护进程，比如getty，会随系统启动但是却很少会被应用到。这时为了释放昂贵的主内存资源，系统会将这部分内存分页移动到swap空间中。上述就是Linux使用swap空间的机制，当swap分区使用超过50％时，并不意味着物理内存的使用已经达到瓶颈了，swap空间只是Linux内核更好的使用系统资源的一种方法。</p>
<p>简单理解：Swap usage只表示了Linux管理内存的有效性。对识别内存瓶颈来说，Swap In/Out才是一个比较又意义的依据，如果Swap In/Out的值长期保持在每秒200到300个页面通常就表示系统可能存在内存的瓶颈。下面的事例是好的状态：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMAnDBWAyys2w9VZTv3N7L3TIMu9OpgibjzRwtJtJzoicgM7iaicBibqlYUNvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="五、模块化的I-O调度器"><a href="#五、模块化的I-O调度器" class="headerlink" title="五、模块化的I/O调度器"></a><strong>五、模块化的I/O调度器</strong></h1><p>就象我们知道的Linux2.6内核为我们带来了很多新的特性，这其中就包括了新的I/O调度机制。旧的2.4内核使用一个单一的I/O调度器，2.6 内核为我们提供了四个可选择的I/O调度器。因为Linux系统应用在很广阔的范围里，不同的应用对I/O设备和负载的要求都不相同，例如一个笔记本电脑和一个10000用户的数据库服务器对I/O的要求肯定有着很大的区别。</p>
<p>（1）Anticipatory</p>
<p>anticipatory I/O调度器创建假设一个块设备只有一个物理的查找磁头（例如一个单独的SATA硬盘），正如anticipatory调度器名字一样，anticipatory调度器使用“anticipatory”的算法写入硬盘一个比较大的数据流代替写入多个随机的小的数据流，这样有可能导致写 I/O操作的一些延时。这个调度器适用于通常的一些应用，比如大部分的个人电脑。</p>
<p>（2）Complete Fair Queuing (CFQ)</p>
<p>Complete Fair Queuing（CFQ）调度器是Red Flag DC Server 5使用的标准算法。CFQ调度器使用QoS策略为系统内的所有任务分配相同的带宽。CFQ调度器适用于有大量计算进程的多用户系统。它试图避免进程被饿死和实现了比较低的延迟。</p>
<p>（3）Deadline</p>
<p>deadline调度器是使用deadline算法的轮询的调度器，提供对I/O子系统接近实时的操作，deadline调度器提供了很小的延迟和维持一个很好的磁盘吞吐量。如果使用deadline算法请确保进程资源分配不会出现问题。</p>
<p>（4）NOOP</p>
<p>NOOP调度器是一个简化的调度程序它只作最基本的合并与排序。与桌面系统的关系不是很大，主要用在一些特殊的软件与硬件环境下，这些软件与硬件一般都拥有自己的调度机制对内核支持的要求很小，这很适合一些嵌入式系统环境。作为桌面用户我们一般不会选择它。</p>
<h1 id="六、网络子系统"><a href="#六、网络子系统" class="headerlink" title="六、网络子系统"></a><strong>六、网络子系统</strong></h1><p>新的网络中断缓和（NAPI）对网络子系统带来了改变，提高了大流量网络的性能。Linux内核在处理网络堆栈时，相比降低系统占用率和高吞吐量更关注可靠性和低延迟。所以在某些情况下，Linux建立一个防火墙或者文件、打印、数据库等企业级应用的性能可能会低于相同配置的Windows服务器。</p>
<p>在传统的处理网络封包的方式中，如下图蓝色箭头所描述的，一个以太网封包到达网卡接口后，如果MAC地址相符合会被送到网卡的缓冲区中。网卡然后将封包移到操作系统内核的网络缓冲区中并且对CPU发出一个硬中断，CPU会处理这个封包到相应的网络堆栈中，可能是一个TCP端口或者Apache应用中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SeWfibBcBT0EuxfhHv3gxaMWjfngI7kMA4LoUKc66wnIUCFdQe1RS1DJibpvj47COXO72FrHl2IMMCczHex2socA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是一个处理网络封包的简单的流程，但从中我们可以看到这个处理方式的缺点。正如我们看到的，每次适合网络封包到达网络接口都将对CPU发出一个硬中断信号，中断CPU正在处理的其他任务，导致切换动作和对CPU缓存的操作。你可能认为当只有少量的网络封包到达网卡的情况下这并不是个问题，但是千兆网络和现代的应用将带来每秒钟成千上万的网络数据，这就有可能对性能造成不良的影响。</p>
<p>正是因为这个情况，NAPI在处理网络通讯的时候引入了计数机制。对第一个封包，NAPI以传统的方式进行处理，但是对后面的封包，网卡引入了POLL 的轮询机制：如果一个封包在网卡DMA环的缓存中，就不再为这个封包申请新的中断，直到最后一个封包被处理或者缓冲区被耗尽。这样就有效的减少了因为过多的中断CPU对系统性能的影响。同时，NAPI通过创建可以被多处理器执行的软中断改善了系统的可扩展性。NAPI将为大量的企业级多处理器平台带来帮助，它要求一个启用NAPI的驱动程序。在今天很多驱动程序默认没有启用NAPI，这就为我们调优网络子系统的性能提供了更广阔的空间。</p>
<h1 id="七、理解Linux调优参数"><a href="#七、理解Linux调优参数" class="headerlink" title="七、理解Linux调优参数"></a><strong>七、理解Linux调优参数</strong></h1><p>因为Linux是一个开源操作系统，所以又大量可用的性能监测工具。对这些工具的选择取决于你的个人喜好和对数据细节的要求。所有的性能监测工具都是按照同样的规则来工作的，所以无论你使用哪种监测工具都需要理解这些参数。下面列出了一些重要的参数，有效的理解它们是很有用处的。</p>
<p>（1）处理器参数</p>
<p>・CPU utilization</p>
<p>这是一个很简单的参数，它直观的描述了每个CPU的利用率。在xSeries架构中，如果CPU的利用率长时间的超过80％，就可能是出现了处理器的瓶颈。</p>
<p>・Runable processes</p>
<p>这个值描述了正在准备被执行的进程，在一个持续时间里这个值不应该超过物理CPU数量的10倍，否则CPU方面就可能存在瓶颈。</p>
<p>・Blocked</p>
<p>描述了那些因为等待I/O操作结束而不能被执行的进程，Blocked可能指出你正面临I/O瓶颈。</p>
<p>・User time</p>
<p>描述了处理用户进程的百分比，包括nice time。如果User time的值很高，说明系统性能用在处理实际的工作。</p>
<p>・System time</p>
<p>描述了CPU花费在处理内核操作包括IRQ和软件中断上面的百分比。如果system time很高说明系统可能存在网络或者驱动堆栈方面的瓶颈。一个系统通常只花费很少的时间去处理内核的操作。</p>
<p>・Idle time</p>
<p>描述了CPU空闲的百分比。</p>
<p>・Nice time</p>
<p>描述了CPU花费在处理re-nicing进程的百分比。</p>
<p>・Context switch</p>
<p>系统中线程之间进行交换的数量。</p>
<p>・Waiting</p>
<p>CPU花费在等待I/O操作上的总时间，与blocked相似，一个系统不应该花费太多的时间在等待I/O操作上，否则你应该进一步检测I/O子系统是否存在瓶颈。</p>
<p>・Interrupts</p>
<p>Interrupts 值包括硬Interrupts和软Interrupts，硬Interrupts会对系统性能带来更多的不利影响。高的Interrupts值指出系统可能存在一个软件的瓶颈，可能是内核或者驱动程序。注意Interrupts值中包括CPU时钟导致的中断（现代的xServer系统每秒1000个 Interrupts值）。</p>
<p>（2）内存参数</p>
<p>・Free memory</p>
<p>相比其他操作系统，Linux空闲内存的值不应该做为一个性能参考的重要指标，因为就像我们之前提到过的，Linux内核会分配大量没有被使用的内存作为文件系统的缓存，所以这个值通常都比较小。</p>
<p>・Swap usage</p>
<p>这 个值描述了已经被使用的swap空间。Swap usage只表示了Linux管理内存的有效性。对识别内存瓶颈来说，Swap In/Out才是一个比较又意义的依据，如果Swap In/Out的值长期保持在每秒200到300个页面通常就表示系统可能存在内存的瓶颈。</p>
<p>・Buffer and cache</p>
<p>这个值描述了为文件系统和块设备分配的缓存。在Red Flag DC Server 5版本中,你可以通过修改/proc/sys/vm中的page_cache_tuning来调整空闲内存中作为缓存的数量。</p>
<p>・Slabs</p>
<p>描述了内核使用的内存空间，注意内核的页面是不能被交换到磁盘上的。</p>
<p>・Active versus inactive memory</p>
<p>提供了关于系统内存的active<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247485329&idx=4&sn=d52185809985d7012a15cfc50119f072&chksm=fe795649c90edf5fa823e702435ee31767598ba753ac2c4be5d95df358265cee977a270f0fbd&scene=21#wechat_redirect">内存</a>信息，Inactive内存是被kswapd守护进程交换到磁盘上的空间。</p>
<p>（3）网络参数</p>
<p>・Packets received and sent</p>
<p>这个参数表示了一个指定网卡接收和发送的数据包的数量。</p>
<p>・Bytes received and sent</p>
<p>这个参数表示了一个指定网卡接收和发送的数据包的字节数。</p>
<p>・Collisions per second</p>
<p>这个值提供了发生在指定网卡上的网络冲突的数量。持续的出现这个值代表在网络架构上出现了瓶颈，而不是在服务器端出现的问题。在正常配置的网络中冲突是非常少见的，除非用户的网络环境都是由hub组成。</p>
<p>・Packets dropped</p>
<p>这个值表示了被内核丢掉的数据包数量，可能是因为防火墙或者是网络缓存的缺乏。</p>
<p>・Overruns</p>
<p>Overruns表达了超出网络接口缓存的次数，这个参数应该和packets dropped值联系到一起来判断是否存在在网络缓存或者网络队列过长方面的瓶颈。</p>
<p>・Errors 这个值记录了标志为失败的帧的数量。这个可能由错误的网络配置或者部分网线损坏导致，在铜口千兆以太网环境中部分网线的损害是影响性能的一个重要因素。</p>
<p>（4）块设备参数</p>
<p>・Iowait</p>
<p>CPU等待I/O操作所花费的时间。这个值持续很高通常可能是I/O瓶颈所导致的。</p>
<p>・Average queue length</p>
<p>I/O请求的数量，通常一个磁盘队列值为2到3为最佳情况，更高的值说明系统可能存在I/O瓶颈。</p>
<p>・Average wait</p>
<p>响应一个I/O操作的平均时间。Average wait包括实际I/O操作的时间和在I/O队列里等待的时间。</p>
<p>・Transfers per second</p>
<p>描述每秒执行多少次I/O操作（包括读和写）。Transfers per second的值与kBytes per second结合起来可以帮助你估计系统的平均传输块大小，这个传输块大小通常和磁盘子系统的条带化大小相符合可以获得最好的性能。</p>
<p>・Blocks read/write per second</p>
<p>这个值表达了每秒读写的blocks数量，在2.6内核中blocks是1024bytes，在早些的内核版本中blocks可以是不同的大小，从512bytes到4kb。</p>
<p>・Kilobytes per second read/write</p>
<p>按照kb为单位表示读写块设备的实际数据的数量。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Linux" style=color:#ff7d73>
                Linux
            </a>
        </span>
        
    </div>

    <a href="/2021/04/02/Linux性能调优/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/01/深入浅出springboot2有感/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="全注解下的spring-ioc"><a href="#全注解下的spring-ioc" class="headerlink" title="全注解下的spring ioc"></a>全注解下的spring ioc</h1><p>spring最成功的便是其提出的两个理念 （ IOC和AOP) 控制反转和面向切面编程。</p>
<p>其中ioc容器思想是spring的核心，而spring是基于注解开发的spring ioc 所以重点分析全注解下的spring ioc。</p>
<p>IoC是一种通过描述来生成或者获取对象的技术，而这个技术不是Spring甚至不是Java独有的。对于Java初学者更多的时候所熟悉的是使用new关键字来创建对象，而在Spring中则不是，它是<strong>通过描述来创建对象</strong>。只是Spring Boot并不建议使用XML，而是通过注解的描述生成对象。</p>
<p>一个系统可以生成各种对象，并且这些对象都需要进行管理。值得一提的事，对象之间并不孤立，它们之间还可能存在依赖的关系。例如，一个班级是由多个老师和同学组成，那么班级就依赖于多个老师和同学。为了解藕，spring还提供了依赖注入的功能，使得我们能够通过描述来管理各个对象之间的关系。</p>
<p>而为了描述上述班级、同学和老师这三个对象关系，我们需要一个容器。在spring中把每一个需要管理的对象称为spring bean，而spring管理这些bean的容器，被我们称为spring ioc容器（或者简称ioc容器）。ioc容器需要具备两个基本功能：</p>
<ul>
<li><p>通过描述管理bean，包括发布和获取bean；</p>
</li>
<li><p>通过描述完成bean之间的依赖关系。</p>
</li>
</ul>
<h2 id="ioc容器分析"><a href="#ioc容器分析" class="headerlink" title="ioc容器分析"></a>ioc容器分析</h2><p>ioc是一个管理bean的容器，在spring的定义中，它要求<strong>所有的ioc容器都需要实现接口beanfactory</strong>，它是一个顶级容器接口。</p>
<p>beanfactory接口源码分析：</p>
<h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><p>在spring中允许我们通过xml或者Java配置文件装配bean，但是由于spring boot是基于注解的方式，因此下面主要基于注解的方式来介绍spring的用法，以满足spring boot开发者的需要。</p>
<h3 id="自动扫描装配Bean"><a href="#自动扫描装配Bean" class="headerlink" title="自动扫描装配Bean"></a>自动扫描装配Bean</h3><p>如果一个个的bean使用注解@Bean注入spring ioc容器中，那将是一件很麻烦的事情。好在spring还允许我们进行扫描装配bean到ioc容器中，对于<strong>扫描装配而言使用的注解是@Component和@componentSca</strong>。<br><strong>@Component是标明哪个类被扫描进入spring ioc容器，而@ComponentScan则是标明采用何种策略去扫描装配Bean</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componente</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">	<span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="meta">@Value(&quot;user_name_1&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="meta">@Value(&quot;note_1&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String note;</span><br><span class="line">	<span class="comment">/** some code about getter and setter**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的注解**@Component表明这个类将被Spring IoC容器扫描装配<strong>，其中配置的“user”则是作为Bean的名称，当然你也可以不配置这个字符串，那么IoC容器就会把类名第一个字母作为小写，其他不变作为Bean名称放入到IoC容器中；</strong>注解@Value则是指定具体的值，使得Spring IoC给予对应的属性注入对应的值**。为了让Spring IoC容器装配这个类，需要改造类AppConfig，如代码清单3-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里加入@ComponentScan,意味着它会进行扫描，但是它只会扫描类AppConfig所在的当前包和其子包，之前把User.java移到包com.springboot.chapter3.config就是这个原因。这样就可以删掉之前使用@Bean标注的创建对象方法。然后进行测试，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">log.info(user.getId());</span><br></pre></td></tr></table></figure>


            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/spring-boot" style=color:#ff7d73>
                spring boot
            </a>
        </span>
        
    </div>

    <a href="/2021/04/01/深入浅出springboot2有感/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/04/01/servlet/">
        <h2>
            servlet
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="古老的技术Servlet"><a href="#古老的技术Servlet" class="headerlink" title="古老的技术Servlet"></a>古老的技术Servlet</h1><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>tomcat是一个web服务器（<strong>同时也是servlet容器</strong>），通过它我们可以很方便地接收和返回到请求（如果不用tomcat，那我们需要自己写socket来接收和返回请求）。</p>
<p>各个目录的含义：</p>
<p>bin：存放启动和关闭tomcat的脚本文件</p>
<p>conf：存放tomcat服务器的各种配置文件</p>
<p>lib：存放tomcat服务器的支撑jar包</p>
<p>logs：存放tomcat的日志文件</p>
<p>temp：存放tomcat运行时产生的临时文件</p>
<p>webapps：web应用所在目录，即供外界访问的web资源的存放目录。</p>
<p>work：tomcat工作目录</p>
<h2 id="Servlet版”hello-world”"><a href="#Servlet版”hello-world”" class="headerlink" title="Servlet版”hello world”"></a>Servlet版”hello world”</h2><p>首先，我们需要认清一个JavaWeb的标准目录结构：</p>
<p>webapps–&gt;bbs(web应用目录)–&gt;html文件，jsp文件</p>
<p>​                                                     –&gt;web-inf目录–&gt;web.xml、taolib.tld</p>
<p>​                                                                               –&gt;classes目录–&gt;类的包目录–&gt;各种class文件标签处理类</p>
<p>​                                                    –&gt;lib目录（web应用需要的jar包）</p>
<h3 id="servlet案例"><a href="#servlet案例" class="headerlink" title="servlet案例"></a>servlet案例</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/java" style=color:#1bccbc>
                java
            </a>
        </span>
        
    </div>

    <a href="/2021/04/01/servlet/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/03/29/HTML课堂笔记/">
        <h2>
            
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/3/29
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web概念概述
2. HTML
</code></pre>
<h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：
    * 使用Java语言开发基于互联网的项目

* 软件架构：
    1. C/S: Client/Server 客户端/服务器端
        * 在用户本地有一个客户端程序，在远程有一个服务器端程序
        * 如：QQ，迅雷...
        * 优点：
            1. 用户体验好
        * 缺点：
            1. 开发、安装，部署，维护 麻烦
    2. B/S: Browser/Server 浏览器/服务器端
        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
        * 优点：
            1. 开发、安装，部署，维护 简单
        * 缺点：
            1. 如果应用过大，用户的体验可能会受到影响
            2. 对硬件要求过高

* B/S架构详解
    * 资源分类：
        1. 静态资源：
            * 使用静态网页开发技术发布的资源。
            * 特点：
                * 所有用户访问，得到的结果是一样的。
                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript
                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
        2. 动态资源：
            * 使用动态网页及时发布的资源。
            * 特点：
                * 所有用户访问，得到的结果可能不一样。
                * 如：jsp/servlet,php,asp...
                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器


    * 我们要学习动态资源，必须先学习静态资源！

    * 静态资源：
        * HTML：用于搭建基础网页，展示页面的内容
        * CSS：用于美化页面，布局页面
        * JavaScript：控制页面的元素，让页面有一些动态的效果
</code></pre>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">1. 概念：是最基础的网页开发语言</span><br><span class="line">	* Hyper Text Markup Language 超文本标记语言</span><br><span class="line">		* 超文本:</span><br><span class="line">			* 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</span><br><span class="line">		* 标记语言:</span><br><span class="line">			* 由标签构成的语言。&lt;标签名称&gt; 如 html，xml</span><br><span class="line">			* 标记语言不是编程语言</span><br><span class="line"></span><br><span class="line">2. 快速入门：</span><br><span class="line">	* 语法：</span><br><span class="line">		1. html文档后缀名 .html 或者 .htm</span><br><span class="line">		2. 标签分为</span><br><span class="line">			1. 围堵标签：有开始标签和结束标签。如 <span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">			2. 自闭和标签：开始标签和结束标签在一起。如 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">		3. 标签可以嵌套：</span><br><span class="line">			需要正确嵌套，不能你中有我，我中有你</span><br><span class="line">			错误：<span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">			正确：<span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</span><br><span class="line">		5. html的标签不区分大小写，但是建议使用小写。</span><br><span class="line"></span><br><span class="line">	* 代码：</span><br><span class="line">		<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">			<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">FONT</span> <span class="attr">color</span>=<span class="string">&#x27;red&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">				</span><br><span class="line">				<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;green&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">		<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">3. 标签学习：</span><br><span class="line">	1. 文件标签：构成html最基本的标签</span><br><span class="line">		* html:html文档的根标签</span><br><span class="line">		* head：头标签。用于指定html文档的一些属性。引入外部的资源</span><br><span class="line">		* title：标题标签。</span><br><span class="line">		* body：体标签</span><br><span class="line">		* <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>：html5中定义该文档是html文档</span><br><span class="line">	2. 文本标签：和文本有关的标签</span><br><span class="line">		* 注释：<span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br><span class="line">		* <span class="tag">&lt;<span class="name">h1</span>&gt;</span> to <span class="tag">&lt;<span class="name">h6</span>&gt;</span>：标题标签</span><br><span class="line">			* h1~h6:字体大小逐渐递减</span><br><span class="line">		* <span class="tag">&lt;<span class="name">p</span>&gt;</span>：段落标签</span><br><span class="line">		* <span class="tag">&lt;<span class="name">br</span>&gt;</span>：换行标签</span><br><span class="line">		* <span class="tag">&lt;<span class="name">hr</span>&gt;</span>：展示一条水平线</span><br><span class="line">			* 属性：</span><br><span class="line">				* color：颜色</span><br><span class="line">				* width：宽度</span><br><span class="line">				* size：高度</span><br><span class="line">				* align：对其方式</span><br><span class="line">					* center：居中</span><br><span class="line">					* left：左对齐</span><br><span class="line">					* right：右对齐</span><br><span class="line">		* <span class="tag">&lt;<span class="name">b</span>&gt;</span>：字体加粗</span><br><span class="line">		* <span class="tag">&lt;<span class="name">i</span>&gt;</span>：字体斜体 </span><br><span class="line">		* <span class="tag">&lt;<span class="name">font</span>&gt;</span>:字体标签</span><br><span class="line">		* <span class="tag">&lt;<span class="name">center</span>&gt;</span>:文本居中</span><br><span class="line">			* 属性：</span><br><span class="line">				* color：颜色</span><br><span class="line">				* size：大小</span><br><span class="line">				* face：字体</span><br><span class="line"></span><br><span class="line">		* 属性定义：</span><br><span class="line">			* color：</span><br><span class="line">				1. 英文单词：red,green,blue</span><br><span class="line">				2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)</span><br><span class="line">				3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF</span><br><span class="line">			* width：</span><br><span class="line">				1. 数值：width=&#x27;20&#x27; ,数值的单位，默认是 px(像素)</span><br><span class="line">				2. 数值%：占比相对于父元素的比例</span><br><span class="line"></span><br><span class="line">		* 案例：公司简介</span><br><span class="line">			<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ch&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">			    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">			    <span class="tag">&lt;<span class="name">title</span>&gt;</span>黑马程序员简介<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">			    公司简介</span><br><span class="line">			<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;#ffd700&quot;</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;#FF0000&quot;</span>&gt;</span>&quot;中关村黑马程序员训练营&quot;<span class="tag">&lt;/<span class="name">font</span>&gt;</span>是由<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span>联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。</span><br><span class="line">			中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;#ffd700&quot;</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;gray&quot;</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">			    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">			        江苏传智播客教育科技股份有限公司<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">			        版权所有Copyright 2006-2018<span class="symbol">&amp;copy;</span>, All Rights Reserved 苏ICP备16007882</span><br><span class="line">			    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>​<br>​<br>                </body><br>                </html></p>
<pre><code>    3. 图片标签：
        * img：展示图片
            * 属性：
                * src：指定图片的位置

        * 代码：
             &lt;!--展示一张图片 img--&gt;

            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;
        
            &lt;!--
                相对路径
                    * 以.开头的路径
                        * ./：代表当前目录  ./image/1.jpg
                        * ../:代表上一级目录
             --&gt;
        
            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;
        
            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;
    4. 列表标签：
        * 有序列表：
            * ol:
            * li:
        * 无序列表：
            * ul:
            * li:
    5. 链接标签：
        * a:定义一个超链接
            * 属性：
                * href：指定访问资源的URL(统一资源定位符)
                * target：指定打开资源的方式
                    * _self:默认值，在当前页面打开
                    * _blank：在空白页面打开

        * 代码：
             &lt;!--超链接  a--&gt;

            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
        
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;
        
            &lt;br&gt;
        
            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;
            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;
        
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;
    6. div和span：
        * div:每一个div占满一整行。块级标签
        * span：文本信息在一行展示，行内标签 内联标签

    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。
        1. &lt;header&gt;：页眉
        2. &lt;footer&gt;：页脚


    8. 表格标签：
        * table：定义表格
            * width：宽度
            * border：边框
            * cellpadding：定义内容和单元格的距离
            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、
            * bgcolor：背景色
            * align：对齐方式
        * tr：定义行
            * bgcolor：背景色
            * align：对齐方式
        * td：定义单元格
            * colspan：合并列
            * rowspan：合并行
        * th：定义表头单元格
        * &lt;caption&gt;：表格标题
        * &lt;thead&gt;：表示表格的头部分
        * &lt;tbody&gt;：表示表格的体部分
        * &lt;tfoot&gt;：表示表格的脚部分
</code></pre>
<h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    
2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
3. 如果某一行有多个单元格，则使用
    &lt;tr&gt;
        &lt;td&gt;
            &lt;table&gt;&lt;/table&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

4. 代码实现

    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;黑马旅游网&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    
        &lt;!--采用table来完成布局--&gt;
        &lt;!--最外层的table，用于整个页面的布局--&gt;
        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
           &lt;!-- 第1行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第2行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
    
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第3行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;
                            &lt;td&gt;
                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
    
                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第4行 轮播图 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第5行 黑马精选--&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;
                    黑马精选
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第6行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第7行 国内游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;
                    国内游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第8行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre>
<p>​<br>                            </tr><br>                        </table><br>                    </td><br>                </tr></p>
<pre><code>            &lt;!-- 第9行 境外游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;
                    境外游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第10行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
    
                        &lt;tr&gt;
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
    
                            &lt;td&gt;
    
                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;!-- 第11行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
    
            &lt;!-- 第12行 --&gt;
            &lt;tr&gt;
                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;
                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;
                    江苏传智播客教育科技股份有限公司
                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882
                    &lt;/font&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            
        &lt;/table&gt;
</code></pre>
<p>​<br>        </body><br>        </html></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2021/03/29/HTML课堂笔记/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/03/23/设计模式/">
        <h2>
            设计模式
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/3/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><p>设计模式代表了最佳的实践，通常被有经验的面相对象的软件开发人员所采用。</p>
<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多</p>
<p>软件开大人员经过相当长的一段时间的试验和错误总结出来的。</p>
<blockquote>
<p>我的个人总结：<strong>工厂模式即是构建接口 利用继承构建多类，然后通过工厂方法实现类的实现，即由原本的new 变成了由工厂的方法产生，多次封装。优点就是隐藏了具体实现而可以更关注逻辑，缺点就是代码量大，但是用框架的就会更简单</strong></p>
</blockquote>
<blockquote>
<p>抽象工厂模式：就是在工厂模式基础上，用工厂生产工厂再由生产的工厂生产类。</p>
</blockquote>
<hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是Java中最常用的设计模式之一。__这种类型的设计模式属于创型模式，它提供了一种创建对象的最佳方式。__工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而且通过使用一个共同的借口来指向新创建的对象。</p>
<p><strong>详细介绍：</strong></p>
<p>意图：<strong>定义一个创建对象的接口，让子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</strong></p>
<p>如何使用：我们明确地计划不同条件下创建不同实例时。</p>
<p>如何解决：让子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>关键代码：创建过程在其子类执行。</p>
<p>应用实例：</p>
<ol>
<li>你需要一辆汽车，可以直接从工厂提货，而不用去管汽车怎么实现的。  </li>
<li>Hibernate 换数据只需要换方言和驱动就可以。  </li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><ol>
<li>一个调用者想创建对象，只需要知道其名称就可以了。</li>
<li> 扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以。  </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ol>
<li>每次增加一个产品，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
<li>还是老缺点，就是增加了代码量。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ol>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>​        作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<p><img src="/Users/kingboom/Desktop/blog_file/source/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210326155319844.png"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>步骤1. </p>
<p>创建一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<p>步骤2.</p>
<p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3.</p>
<p>创建一个工厂，生成基于给定信息的实体类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4.</p>
<p>使用该工厂，通过传递类型信息来获取实体类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤5.</p>
<p>执行程序，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></table></figure>


<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>​        抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>介绍</p>
<p>意图：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>主要解决：主要解决接口选择的问题。</p>
<p>何时使用：系统的产品有多于以一个的产品族，而系统只消费其中某一族的产品。</p>
<p>如何解决：在一个产品族里面，定义多个产品。</p>
<p>关键代码：在一个工厂里聚合多个同类产品。</p>
<p>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用其中同一个产品族中的对象。</p>
<h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>产品族扩展非常困难，要增加一个系列的某一个产品，既要在抽象的creator里加代码，又要在具体的里面加代码。</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>注意事项：产品族难扩展，产品等级易扩展。</p>
<h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="/Users/kingboom/Desktop/blog_file/source/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210326163439322.png"></p>
<p>步骤1 为形状创建一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<p>步骤2 创建实现接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;    <span class="meta">@Override</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);   &#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3 为颜色创建一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Red::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Green::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Blue::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤5 为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤6 创建扩展了AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;RED&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;GREEN&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;BLUE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;SHAPE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;COLOR&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤 8 使用FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">&quot;SHAPE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">&quot;COLOR&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤9 run</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br><span class="line">Inside Red::fill() method.</span><br><span class="line">Inside Green::fill() method.</span><br><span class="line">Inside Blue::fill() method.</span><br></pre></td></tr></table></figure>


            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/To-be God" style=color:#879cff>
                To be God
            </a>
        </span>
        
    </div>

    <a href="/2021/03/23/设计模式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/03/23/灰度发布/">
        <h2>
            灰度发布
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/categories">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                categories
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/3/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="1-什么是灰度发布"><a href="#1-什么是灰度发布" class="headerlink" title="1.什么是灰度发布"></a>1.什么是灰度发布</h1><p>​        灰度发布是指A/B testing,即让一部分用户继续用产品特性a，一部分开始用产品特性b,如果用户对b没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到b上面。</p>
<h1 id="2-灰度发布流程"><a href="#2-灰度发布流程" class="headerlink" title="2.灰度发布流程"></a>2.灰度发布流程</h1><p>![image-20210323154759087](/Users/kingboom/Library/Application Support/typora-user-images/image-20210323154759087.png)</p>
<p>相关解释：</p>
<p>​        选定策略：包括用户规模、发布频率、功能覆盖率、回滚策略、运营策略、新旧系统部署策略等；</p>
<p>​        筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等</p>
<p>​        部署系统：部署新系统、部署用户行为分析系统、设定分流规则、运营数据分析、分流规则微调</p>
<p>​        发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表 </p>
<h1 id="3-Eureka实现灰度发布（优雅下线）"><a href="#3-Eureka实现灰度发布（优雅下线）" class="headerlink" title="3.Eureka实现灰度发布（优雅下线）"></a>3.Eureka实现灰度发布（优雅下线）</h1><ol>
<li><p>直接停掉服务。</p>
<p>​        默认情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。但这种做法的不好之处在于， 客户端已经停止了运行，但仍然在注册中心的列表中。 虽然通过一定的负载均衡策略或使用熔断器可以让服务正常进行，但有没有方法让注册中心马上知道服务已经下线呢？</p>
</li>
<li><p>为了让注册中心马上知道服务要下线，可以向euraka注册中心发送delete请求</p>
<pre><code>    格式为/eureka/apps/&#123;application.name&#125;
</code></pre>
</li>
<li><p>客户端主动通知注册中心下线</p>
<p>​        如果你的eureka客户端是是一个spring boot应用，可以通过调用以下代码通知注册中心下线。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent();</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient client;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java.util.List&lt;ServiceInstance&gt; instances = client.getInstances(<span class="string">&quot;hello-service&quot;</span>);       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/offline&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	DiscoveryManager.getInstance().shutdownComponent();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/linux运维" style=color:#ff7d73>
                linux运维
            </a>
        </span>
        
    </div>

    <a href="/2021/03/23/灰度发布/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/avatar.png " alt="头像">
        </div>
        <div class="name">
            phenix-fledgling
        </div>
        <div class="descriptions">
            
            <div class="description">
                蜻蜓拂澜万波生，震碎人间失意人
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/korilin">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a href="www.baidu.com">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a href="www.baidu.com">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2021 Hexo
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @phenix-fledgling
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>